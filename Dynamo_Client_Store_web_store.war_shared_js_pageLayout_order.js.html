<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Dynamo/Client/Store/web/store.war/shared/js/pageLayout/order.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Dynamo/Client/Store/web/store.war/shared/js/pageLayout/order.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @fileoverview Defines an OrderViewModel used to represent and maintain an
 *               order.
 */
/* global $ */
/* global define */
define(
    // -------------------------------------------------------------------
    // PACKAGE NAME
    // -------------------------------------------------------------------
    'pageLayout/order',

    // -------------------------------------------------------------------
    // DEPENDENCIES
    // -------------------------------------------------------------------
    [ 'knockout', 'pubsub', 'notifier', 'CCi18n', 'ccLogger', 'ccRestClient',
        'ccConstants', 'jquery', 'navigation', 'spinner', 'viewModels/address',
        'viewModels/paymentDetails', 'viewModels/giftCardViewModel',
        'storageApi', 'viewModels/dynamicProperty' , 'ccStoreServerLogger',
        'viewModels/cashViewModel', 'pageViewTracker', 'sfExceptionHandler', 
        'ccStoreConfiguration', 'viewModels/paymentsViewModel', 'pageLayout/site', 'currencyHelper'],

    // -------------------------------------------------------------------
    // MODULE DEFINITION
    // -------------------------------------------------------------------
    function(ko, pubsub, notifier, CCi18n, log, ccRestClient, ccConstants, $,
        navigation, spinner, address, PaymentDetails, GiftCardViewModel, 
        storageApi, DynamicProperty, StoreServerLogger, cashModel, pageViewTracker, 
        ExceptionHandler, CCStoreConfiguration, paymentsViewModel, SiteViewModel, currencyHelper) {

      "use strict";

      // ------------------------------------------------------------------
      // Class definition &amp; member variables
      // ------------------------------------------------------------------

      var ORDER_VIEW_MODEL_ID = "OrderViewModel";

      /**
       * Creates an order view model.
       * 
       * @public
       * @name OrderViewModel
       * @param {RestAdapter}
       *          pAdapter The rest adapter.
       * @param {CartViewModel}
       *          pCart The cart.
       * @param {Object}
       *          [pData] Additional data passed to the view model.
       * 
       * @property {RestAdapter} adapter An adapter used to make the REST calls.
       * @property {CartViewModel} cart The shopping cart
       * @property {observable&lt;string>} id The ID of the view model.
       * @property {observable&lt;Address>} billingAddress The valid billing
       *           address.
       * @property {observable&lt;Address>} shippingAddress The valid shipping
       *           address.
       * @property {observable&lt;string>} emailAddress The order email address.
       * @property {observable&lt;string>} orderProfileId The order profile ID.
       * @property {observable&lt;OrderViewModel.PaypalPaymentDetails>} paymentGateway Payment details.
       * @property {observable&lt;Object>} selectedShippingOption The selected
       *           shipping option.
       * @property {observable&lt;boolean>} isPaypalVerified Has the paypal
       *           account been verified?
       * @property {observable&lt;Object>} order The current order.
       * @property {observable&lt;Object>} giftCards Array of the applied GiftCards.
       * @property {observable&lt;boolean>} isInvoicePayment Whether using invoice payment as payment method.
       * @property {observable&lt;Object>} poNumber Purchase order number for invoice payment.
       * @property {CCStoreConfiguration} storeConfiguration An instance of the cc-store-configuration containing store-configuration data.
       * @class Represents an order.
       */
      function OrderViewModel(pAdapter, pCart, pData, pUser) {

        if (OrderViewModel.prototype.singleInstance) {
          throw new Error(
              "Cannot instantiate more than one OrderViewModel, use OrderViewModel.getInstance(pAdapter, pCart, pData)");
        }

        var self = this;
        //Loading agent specific viewmodel
        if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
          self.agentConfiguration = require('agentViewModels/agentConfiguration');
          self.contextManager = require('agentViewModels/agent-context-manager');
        }

        //This variable hold clone order realted data which came as part of initiate amend endpoint response
        self.cloneOrderData = ko.observable("");

        self.adapter = pAdapter;
        self.cart = pCart;
        self.restClient = ccRestClient;

        // Schedule order details
        self.schedule = ko.observable();
        self.showSchedule = ko.observable(false);

        self.id = ko.observable();
        self.billingAddress = ko.observable();
        self.shippingAddress = ko.observable();
        self.shippingAddressAsBilling = ko.observable(false);
        self.paymentDetails = ko.observable(PaymentDetails.getInstance());
        self.paymentsViewModel = ko.observable(paymentsViewModel.getInstance());
        self.emailAddress = ko.observable();
        self.order = ko.observable();
        self.orderProfileId = ko.observable();
        self.paymentGateway = ko.observable();
        self.selectedShippingOption = ko.observable();
        self.isPaypalVerified = ko.observable(false);
        self.isPayULatamCheckout = ko.observable(false);
        self.op = ko.observable();
        self.giftCards = ko.observableArray([]);
        self.amountRemaining = ko.observable();
        self.amountRemaining(null);
        self.isCashPayment = ko.observable(false);
        self.cashModel = ko.observable(cashModel.getInstance());
        self.cashModel().isPayingByCash(self.isCashPayment());
        self.isInvoicePayment = ko.observable(false);
        self.isPayLater = ko.observable(false);
        self.poNumber = ko.observable();
        self.isOrderValid = ko.observable(false);
        self.isSplitPayment = ko.observable(false);
        self.isShippingAddressModified = false;
        self.isBillingAddressModified = false;
        self.isInStorePayment = false;

        self.enableOrderButton = ko.observable(true);
        self.isOrderLocked = false;
        self.isOrderEditable = ko.observable(true);
        self.isOrderSubmitted = false;
        self.checkoutGuest = ko.observable(ccConstants.GUEST);
        self.checkoutLogin = ko.observable(ccConstants.LOGIN);
        // Keeping the guest as the default check option
        self.checkoutOption =   ko.observable(ccConstants.GUEST).extend({ throttle: 400 });
        self.guestEmailAddress = ko.observable('');
        self.createAccount = ko.observable(false);
        
        self.user = pUser;
        self.registerUser = false;
        self.webCheckoutShippingMethodValue = null;
        self.storeServerLog = StoreServerLogger.getInstance();
        self.exceptionHandler = new ExceptionHandler();
        self.loadedOrderShippingAddress = null;

        // This function added to evaluate the value of 
        //isPaymentDisabled flag in case of multi currency
        self.isPaymentDisabled = function(){
          var total = self.cart().getDerivedTotal(
            self.cart().secondaryCurrencyTotal(), self.cart().total());

          return total == 0;
        }

        // generic payments
        self.payments = ko.observableArray([]);
        self.approvalRequired = ko.observable(false);
        self.isAutherizeCalled = false;
        // validation callbacks
        self.validationCallbacks = [];
        
        self.fields = null;
        self.storeConfiguration = CCStoreConfiguration.getInstance();

        self.isCashPayment.subscribe(function(newValue) {
          self.cashModel().isPayingByCash(newValue);
        });
        
        self.registerSplitPaymentCallbacks = function(success, error, validate, apiCall, validatePaymentBillingAddress) {
        	self.createOrderSuccessHandler = success;
          self.createOrderFailureHandler = error;
          self.validateSplitPaymentsHandler = validate;
          self.invokePaymentsAPIHandler = apiCall;
          self.validateSplitPaymentsBillingAddresses = validatePaymentBillingAddress;
        }
        self.registerPendingPaymentCallback = function(callbackFunction){
          self.pendingPaymentOrderHandler = callbackFunction;
        };
        self.validOrderQuantityMap = {};
        self.guestEmailAddress.subscribe(function(newValue) {
          if (self.guestEmailAddress.isValid()) {
        	self.cart().emailAddressForGuestUser = self.guestEmailAddress();
          } else {
        	self.cart().emailAddressForGuestUser = "";
          }
        });
        
        self.registerPointsPaymentCallbacks = function(validatePointsPaymentHandler) {
          self.validatePointsPaymentHandler = validatePointsPaymentHandler;
        };
        self.registerUpdateShippingAddressDynamicPropertiesCallback = function(addressDynamicPropertiesHandler) {
          self.addDynamicPropertiesToAddressHandler = addressDynamicPropertiesHandler;
        };
        /**
         * Update shipping address on a CHECKOUT_BILLING_ADDRESS event.
         * @private
         * @function OrderViewModel#updateBillingAddress
         */
        self.updateBillingAddress = function() {
          self.billingAddress(this);
        };
                
        /**
         * Prepare PayULatam Payment Data for Create Order.
         * @private
         * @function OrderViewModel#preparePayULatamDataForCreateOrder
         * @param {string} type PayPal Payment type.
         * @param {Object} paymentDetails PaymentDetails.
         */
        self.preparePayULatamDataForCreateOrder = function(type) {
          self.paymentGateway(
              new PayULatamPaymentDetails(
                type, self.cart().total(), self.cart().currency.currencyCode)
          );
        };

        /**
         * Update shipping address on a CHECKOUT_SHIPPING_ADDRESS event.
         * @private
         * @function OrderViewModel#updateShippingAddress
         */
        self.updateShippingAddress = function() {
          self.shippingAddress(this);
          // This is done as a workaround to avoid multiple pricing calls. 
          // All  widgets and view-models will update the shipping address in the cart. Cart will decide if the pricing has to be called and will avoid widgets calling pricing directly.
          // Retaining the  shippingAdress of order for backward compatibilty. We should remove this from the order in the future. 
          var shippingAddressWithProductIDs = {};
          shippingAddressWithProductIDs[ccConstants.SHIPPING_ADDRESS_FOR_METHODS] = self.shippingAddress();
          shippingAddressWithProductIDs[ccConstants.PRODUCT_IDS_FOR_SHIPPING] = pCart().getProductIdsForItemsInCart();
            
          pCart().updateShippingAddress.bind(shippingAddressWithProductIDs)();
        };

        /**
         * Update PayPal Payment Type.
         * @private
         * @function OrderViewModel#updatePaypalPaymentType
         * @param {string} type PayPal Payment type.
         */
        self.updatePaypalPaymentType = function(type) {
          var customProperties;
          if (self.paymentGateway() &amp;&amp; self.paymentGateway().type === type &amp;&amp;
              self.paymentGateway().customProperties) {
            customProperties = self.paymentGateway().customProperties;
          }
          self.paymentGateway(new PaypalPaymentDetails(type));
          if (customProperties) {
            self.paymentGateway().customProperties = customProperties;
          }
        };

        /**
         * Update shipping method on a CHECKOUT_SHIPPING_METHOD event.
         * @private
         * @function OrderViewModel#updateShippingMethod
         */
        self.updateShippingMethod = function() {
          if (this &amp;&amp; this.repositoryId) {
            var shippingItem = {};
            shippingItem.value = this.repositoryId;
            shippingItem.shippingOption = this;
            self.selectedShippingOption(shippingItem);
          } else {
            self.selectedShippingOption('');
          }
        };

        /**
         * Update the email address on a CHECKOUT_EMAIL_ADDRESS event.
         * @private
         * @function OrderViewModel#updateEmail
         */
        self.updateEmail = function() {
          self.emailAddress(this);
        };

        /**
         * Reset the billing and shipping addresses.
         * @private
         * @function OrderViewModel#resetAddress
         */
        self.resetAddress = function() {
          if (self.billingAddress()) {
            self.billingAddress().reset();
          }
          if (self.shippingAddress()) {
            self.shippingAddress().reset();
          }
        };

        /**
         * Reset the order ID.
         * @private
         * @function OrderViewModel#resetOrderId
         */
        self.resetOrderId = function() {
          self.id('');
        }

        /**
         * Update payment details on a CHECKOUT_PAYMENT_DETAILS event.
         * @private
         * @function OrderViewModel#updatePaymentDetails
         */
        self.updatePaymentDetails = function() {
          var details = this;  
        
          if (self.paymentDetails &amp;&amp; self.paymentDetails()) {
            for (var prop in details) {
              if (self.paymentDetails()[prop]) {
                self.paymentDetails()[prop](details[prop]);
              }
            }
          }
          else {
            self.paymentDetails(details);  
          }
        };

        /**
         * Update Payment Gateway data on a page change.
         * @private
         * @function OrderViewModel#updatePaymentGatewayData
         * @param {Object} data Page change data.
         */
        self.updatePaymentGatewayData = function(data) {
          var parameterString = data.parameters;
          if (parameterString) {
            var params = parameterString.split('&amp;');
            var result = {};
            for (var i = 0; i &lt; params.length; i++) {
              var entries = params[i].split('=');
              result[entries[0]] = entries[1];
            }
            
            if (result[ccConstants.PAYMENT_ID] &amp;&amp; result[ccConstants.TOKEN] &amp;&amp; result[ccConstants.PAYER_ID]) {
              self.paymentGateway(new PaypalPaymentDetails(
                  ccConstants.PAYPAL_CHECKOUT_TYPE,
                  result[ccConstants.PAYMENT_ID], result[ccConstants.TOKEN],
                  result[ccConstants.PAYER_ID]));
              self.isPaypalVerified(true);
              
            } else if (parameterString.indexOf(ccConstants.PAYU_REFERENCE_POL) != -1) {
              self.createSpinner();
              var txstatus_payu = result[ccConstants.PAYU_TRANSACTION_STATE];
              if (txstatus_payu == ccConstants.PAYU_TRANSACTION_APPROVED_CODE || 
                  txstatus_payu == ccConstants.PAYU_TRANSACTION_PENDING_CODE || 
                  txstatus_payu == ccConstants.PAYU_TRANSACTION_DECLINED_CODE || 
                  txstatus_payu == ccConstants.PAYU_TRANSACTION_EXPIRED_CODE || 
                  txstatus_payu == ccConstants.PAYU_TRANSACTION_ERROR_CODE) {
                var referenceCode = result[ccConstants.PAYU_REFERENCE_CODE];
                var tx_value = result[ccConstants.PAYU_TX_VALUE];
                var currency = result[ccConstants.CURRENCY];
                var signature = result[ccConstants.SIGNATURE];
                self.paymentGateway(new PayULatamPaymentDetails(
                    ccConstants.PAYULATAM_CHECKOUT_TYPE, tx_value, currency, referenceCode, 
                    txstatus_payu, ccConstants.PAYULATAM_RESPONSE_TYPE, signature));
                self.getOrder();
              }
            } else {
              self.clearPaypalData();
            }
          } // When user navigates away from paypal checkout page.
          else if (self.isPaypalVerified() &amp;&amp; !(navigation.getPathWithoutLocale() == self.checkoutLink)) {
            self.clearPaypalData();
          }
        };
        
        /**
         * Loads an order to the checkout page with proper shipping address and
         * shipping groups
         * 
         * @function
         * @name OrderViewModel#loadOrderForSubmit
         * @param {Object} data the page data
         */
        self.loadOrderForSubmit = function(data) {
            var self = this;
            if (((data.pageId == ccConstants.PAGE_TYPE_CHECKOUT)  &amp;&amp; (self.user()) &amp;&amp;
                    (self.user().loggedIn() &amp;&amp; (!self.user().isUserSessionExpired())) &amp;&amp;
                    (self.cart().currentOrderId())) ||
                    ((data.pageId == ccConstants.PAGE_TYPE_AGENT_CHECKOUT || data.pageId == ccConstants.PAGE_TYPE_AGENT_MULTISHIP_CHECKOUT
                      || data.pageId == ccConstants.AGENT_ORDER_DETAILS_PAGE_TYPE) &amp;&amp; self.cart().currentOrderId())) {
              // Get the order
              var pageId = data.pageId;
              var data = {};
              var contextObj = {};
              contextObj[ccConstants.ENDPOINT_KEY] = ccConstants.ENDPOINT_GET_ORDER;
              contextObj[ccConstants.IDENTIFIER_KEY] = "orderForSubmit";
              var filterKey = self.storeConfiguration.getFilterToUse(contextObj);
              if (filterKey) {
                data[ccConstants.FILTER_KEY] = filterKey;
              }
              data[ccConstants.INCLUDE_RESULT] = "full";
              ccRestClient.request(ccConstants.ENDPOINT_GET_ORDER, data,
                function(order) {
                  // For now we will only allow orders in incomplete or quoted state.

                  var state = order.hasOwnProperty('stateString') ? order.stateString : order.state;
                  if (state == ccConstants.QUOTED_STATES || state == ccConstants.INCOMPLETE) {
                	  	// Load the order and stop using the cart items
                	  self.cart().loadOrderForProfile(order, self.user);
                	  	// Now load the shipping address
                	  $.Topic(pubsub.topicNames.LOADED_ORDER_SHIPPING_ADDRESS)
                	  	.publish(order.shippingAddress);
                   if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
                     if(self.shippingAddress &amp;&amp; self.shippingAddress() &amp;&amp; self.shippingAddress().validateForShippingMethod()){
                       self.cart().shippingAddress(self.shippingAddress());
                       self.cart().shippingMethod(order.shippingMethod.value);
                       self.cart().populateShipppingMethods();
                     }
                   } else {
                     self.cart().shippingMethod(order.shippingMethod.value);
                   }
                      // Now fix the shipping method
                      // Add the user order details
                    self.user().orderId(self.cart().currentOrderId());
                    self.user().setLocalData('orderId');
                  } 
                  else if(state==ccConstants.PENDING_PAYMENTS || state==ccConstants.PENDING_PAYMENT_TEMPLATE)
                  {
                      self.isOrderEditable(false);
                    	// Load the order and stop using the cart items
                      self.cart().loadOrderForProfile(order, self.user);
                      if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
                        self.isAnonymousCheckout = order.profile.isAnonymous ? true : false;
                        self.populatePaymentsViewModel(order);
                        if(self.pendingPaymentOrderHandler &amp;&amp; $.isFunction(self.pendingPaymentOrderHandler)){
                          self.pendingPaymentOrderHandler();
                        }
                      }

                      if (order.shippingGroups[0].type == ccConstants.HARDGOOD_SHIPPING_GROUP_TYPE) {
                          // Now load the shipping address
                        var translateHelper =  {
                                translate: function(key, options) {
                                  return CCi18n.t('ns.common:resources.' + key, options);
                                }
                              };
                        var shippingAddress = new address('cart-shipping-address', '', translateHelper, self.contextData.page.shippingCountriesPriceListGroup, self.contextData.page.defaultShippingCountry);
                        shippingAddress.copyFrom(order.shippingGroups[0].shippingAddress, self.contextData.page.shippingCountriesPriceListGroup);
                        shippingAddress.resetModified();
                        //Load shipping Address in Cart
                        $.Topic(pubsub.topicNames.CHECKOUT_SHIPPING_ADDRESS)
                        .publishWith(shippingAddress,[{message:"success"}]);
                                       
                          // Now fix the shipping method
                        var shippingAddressWithProductIDs = {};
                        shippingAddressWithProductIDs[ccConstants.SHIPPING_ADDRESS_FOR_METHODS] = self.shippingAddress();
                        shippingAddressWithProductIDs[ccConstants.PRODUCT_IDS_FOR_SHIPPING] = pCart().getProductIdsForItemsInCart();

                        $.Topic(pubsub.topicNames.VERIFY_SHIPPING_METHODS).publishWith(shippingAddressWithProductIDs, [{
                            message: "success"
                          }]);

                        self.cart().shippingMethod(order.shippingMethod.value);
                      }
                      $.Topic(pubsub.topicNames.LOADED_ORDER_SHIPPING_ADDRESS).publish(order.shippingAddress);
                      self.loadedOrderShippingAddress = order.shippingAddress;
                      var amountRemaining = self.cart().getDerivedTotal(order.priceInfo.secondaryCurrencyTotal, order.priceInfo.total);
                      self.amountRemaining(amountRemaining);
                      $.Topic(pubsub.topicNames.CART_UPDATED_PENDING_PAYMENT).publish(self);
                      if(order.scheduledOrder &amp;&amp; order.scheduledOrder.length>0){
                        self.showSchedule(true);
                        if(self.schedule()){
                          self.schedule().fromJS(order.scheduledOrder[0]);
                        }
                      }
                        // Add the user order details
                      self.user().orderId(self.cart().currentOrderId());
                      self.user().setLocalData('orderId');
                      if(!self.isAutherizeCalled){
                        notifier.sendWarning(ORDER_VIEW_MODEL_ID, CCi18n.t('ns.common:resources.orderCannotBeUpdatePendingPaymentText'), true);  
                      }
                      if (!self.emailAddress() &amp;&amp; self.user().emailAddress()) {
                        self.emailAddress(self.user().emailAddress());
                      }
                  }else if(state==ccConstants.INCOMPLETE_CANCEL){
                    self.isOrderEditable(false);
                  }
                  else {
                	  // If not go 404
                    navigation.goTo(self.contextData.global.links['404'].route);
                  }
                },
                function(data) {
                	// If not go 404
                  navigation.goTo(self.contextData.global.links['404'].route);
                }, 
                self.cart().currentOrderId());
            }
            self.isOrderEditable(true);
        };
        
        /**
         * Update all payments for the order.
         * Removes any existing.
         * @function OrderViewModel#updatePayments
         * @param {String} pPayments the new payments array
         */
        self.updatePayments = function(pPayments) {
          self.payments([]);
          var length = pPayments.length;
          for (var i = 0; i &lt; length; i++) {
            self.payments().push(pPayments[i]);
          }
        };
        
        /**
         * Add payment to the list for the order.
         * @function OrderViewModel#addPayment
         * @param {string} pPayment the new payment.
         */
        self.addPayment = function(pPayment) {
          self.payments.push(pPayment);
        };
        
        /**
         * Returns true if the current payments has the specified type.
         * @function OrderViewModel#addPayment
         * @param {string} pPaymentType.
         */
        self.hasPaymentType = function(pPaymentType) {
          var length = self.payments().length;
          for (var i = 0; i &lt; length; i++) {
            if (self.payments()[i].type === pPaymentType) {
              return true;
            }
          }
          return false;
        };

        /**
         * Determine if there are any validation errors with ShippingGroupRelationships in the cart, if there are the 
         * relevant error messages are displayed to the user.
         * &lt;b>NB&lt;/b> this validation is only relevant is split shipping is is selected.
         *
         * @private
         * @function OrderViewModel#validateShippingGroupRelationships
         * @param {string} pPaymentType.
         */
        self.validateShippingGroupRelationships = function () {
          // clear any previous errors
          notifier.clearError("checkoutAddressBook-ShippingGroupRelationships");

          // If the split shipping user selections in the cart are invalid, flag an error.
          if (!this.cart().hasSplitShippingInformation() &amp;&amp; !this.errorFlag) {
            this.errorFlag = true;
            notifier.sendError("checkoutAddressBook-ShippingGroupRelationships", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
          } else {
            var pickupDetailsMap = {};
            this.errorFlag = !(this.cart().items().every(function (cartItem) {
              return cartItem.shippingGroupRelationships().every(function (shippingGroupRelationship) {
                if(shippingGroupRelationship.isPickupInStore()){
                  if(!pickupDetailsMap[shippingGroupRelationship.selectedStore().locationId+shippingGroupRelationship.availablePickupDate()]){
                    pickupDetailsMap[shippingGroupRelationship.selectedStore().locationId+shippingGroupRelationship.availablePickupDate()] = shippingGroupRelationship.firstName() + shippingGroupRelationship.lastName() + shippingGroupRelationship.phoneNumber();
                  } else {
                    if(pickupDetailsMap[shippingGroupRelationship.selectedStore().locationId+shippingGroupRelationship.availablePickupDate()] !== shippingGroupRelationship.firstName() + shippingGroupRelationship.lastName() + shippingGroupRelationship.phoneNumber()){
                      return false;
                    }
                  }
                }
                return true;
              });
          }));
            if(this.errorFlag){
              notifier.sendError("checkoutAddressBook-ShippingGroupRelationships", CCi18n.t('ns.common:resources.pickupDetailsErrorMsg'), true);
            }
          }
        };

          self.validateShippingAddress = function () {
            // clear any previous errors
            notifier.clearError("checkoutAddressBook-Shipping");

            if (self.shippingAddress) {
              if (!self.shippingAddress().validateNow() &amp;&amp; !this.errorFlag) {
                //error in shippingAddress
                this.errorFlag = true;
                notifier.sendError("checkoutAddressBook-Shipping", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
              } else {
                this.shippingAddress().afterValidation = true;
              }
            }
            if(self.addDynamicPropertiesToAddressHandler &amp;&amp; $.isFunction(self.addDynamicPropertiesToAddressHandler)){
              self.addDynamicPropertiesToAddressHandler(this.shippingAddress());
            }
          };
		  
          self.validateSchedule = function () {
            // clear any previous errors
            notifier.clearError("checkoutScheduledOrder-Schedule");

            if (self.showSchedule() &amp;&amp; self.schedule) {
              if (!self.schedule().validateNow() &amp;&amp; !this.errorFlag) {
                //error in schedule
                this.errorFlag = true;
                notifier.sendError("checkoutScheduledOrder-Schedule", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
              } else {
                this.schedule().afterValidation = true;
              }
            }
          };
            
          self.validateBillingAddress = function () {
            // clear any previous errors
            notifier.clearError("checkoutAddressBook-Billing");
            notifier.clearError("splitPayments-Billing");
            
            if (!self.isSplitPayment() &amp;&amp; ! self.billingAddress().phoneNumber.isValid()){
              self.billingAddress().phoneNumber(self.shippingAddress().phoneNumber());
            }
    
            if (self.isSplitPayment()) {
              if (self.validateSplitPaymentsBillingAddresses 
                &amp;&amp; !self.validateSplitPaymentsBillingAddresses()) {
                this.errorFlag = true;
                notifier.sendError("splitPayments-Billing", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
              }
            } else if (self.billingAddress &amp;&amp; !self.isPaypalVerified() &amp;&amp; self.billingAddress()
                &amp;&amp; !self.billingAddress().validateNow() &amp;&amp; !this.errorFlag) {
              this.errorFlag = true;
              notifier.sendError("checkoutAddressBook-Billing", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
            }

          };

          self.validateCheckoutCartSummary = function () {
            // clear any previous errors
            notifier.clearError("checkoutCartSummary");

            if (self.cart().items().length === 0 &amp;&amp; !this.errorFlag) {
              //error in cart summary
              this.errorFlag = true;
              notifier.sendError("checkoutCartSummary", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
            }
          };

          self.validateCheckoutOrderSummary = function () {
            if (this.selectedShippingOption &amp;&amp; !this.selectedShippingOption() &amp;&amp; !this.errorFlag) {
              this.errorFlag = true;
              notifier.sendError("checkoutOrderSummary", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
            } else {
              // clear any previous error messages.
              notifier.clearError('checkoutOrderSummary-shippingMethods');
            }
          };

          self.validateCheckoutPaymentDetails = function () {
            // clear any previous errors
            notifier.clearError("checkoutPaymentDetails");
            // Validate the checkout payment details, if secondary currency total is greater than zero
            var total = self.cart().getDerivedTotal(this.cart().secondaryCurrencyTotal(), this.cart().total());
            if (this.paymentDetails &amp;&amp; this.payments() &lt; 1 &amp;&amp; (total > 0 || this.paymentDetails().isModified())) {
              if (!this.isPaypalVerified() &amp;&amp; !this.cashModel().isPayingByCash() &amp;&amp; !this.isPayULatamCheckout() &amp;&amp; !this.isInvoicePayment() &amp;&amp;
                  !(this.showSchedule() &amp;&amp; !this.paymentDetails().isCardEnabledForScheduledOrder())) {
                if ((this.amountRemaining() == null || this.amountRemaining() > 0) &amp;&amp;!this.paymentDetails().validatePaymentDetails() &amp;&amp; !this.errorFlag) {
                  this.errorFlag = true;
                  notifier.sendError("checkoutPaymentDetails", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
                }
              }
            }
          };

          self.validateGiftcards = function () {
            // clear any previous errors
            notifier.clearError("checkoutGiftCards");

            if (this.giftCards &amp;&amp; this.giftCards().length > 0) {
                if(!this.cart().validateGiftCards()) {
                  $.Topic(pubsub.topicNames.SHOW_GIFT_CARD_ERROR_PANEL).publish();
                  if(!this.errorFlag){
                  this.errorFlag = true;
                  notifier.sendError("checkoutGiftCards", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);}
                }
              }
          };
          
          self.validatePaymentMethodsForScheduledOrder = function () {
            // clear any previous errors
            notifier.clearError("checkoutPaymentMethodsForScheduledOrder");
            if (this.showSchedule()) {
              if (!(this.cashModel().isPayingByCash() || (this.paymentDetails &amp;&amp;
                this.paymentDetails().isCardEnabledForScheduledOrder())  || (this.giftCards &amp;&amp; this.giftCards().length > 0) 
			      || this.isInvoicePayment() || this.isPayULatamCheckout() || this.isPaypalVerified()) &amp;&amp; !this.errorFlag) {
                    this.errorFlag =true;
                    notifier.sendError("checkoutPaymentMethodsForScheduledOrder", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
              }
			}
          };

          self.validateRegisteredUser = function () {
            this.user().validateLogin();
            if (!this.user().isLoginValid() &amp;&amp; !this.errorFlag) {
              this.errorFlag = true;
              notifier.sendError("checkoutRegistration", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
            } else {
              $.Topic(pubsub.topicNames.CHECKOUT_EMAIL_ADDRESS).publishWith(
                this.user().emailAddress(),[{message:"success"}]);
              $.Topic(pubsub.topicNames.USER_PROFILE_UPDATE_SUBMIT).publishWith(
                this.user(), [{message: "success"}]);
            }
          };

          self.validateGuestUser = function () {
            if (!this.guestEmailAddress.isValid() &amp;&amp; this.createAccount() === false) {
              this.guestEmailAddress.isModified(true);
              if(!this.errorFlag){
                this.errorFlag = true;
                notifier.sendError("checkoutRegistration", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
              }
            } else if (!this.user().isValid() &amp;&amp; this.createAccount() === true) {
              this.user().validateUser();
              if(!this.errorFlag){
              this.errorFlag = true;
              notifier.sendError("checkoutRegistration", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);}
            } else {
              var currentLocale = ccRestClient.getStoredValue(ccConstants.LOCAL_STORAGE_USER_CONTENT_LOCALE);
              if (currentLocale != null) {
                currentLocale = JSON.parse(currentLocale);
                $.Topic(pubsub.topicNames.CHECKOUT_USER_LOCALE).publishWith(
                  (currentLocale[0].name), [{
                    message: "success"}]);
              }
              $.Topic(pubsub.topicNames.CHECKOUT_EMAIL_ADDRESS).publishWith(
                this.guestEmailAddress(), [{message:"success"}]);
            }
          };
          
          self.validateCheckoutRegistration = function () {
            // clear any previous errors
            notifier.clearError("checkoutRegistration");

            if (!this.user().loggedIn()) {
              if (this.checkoutOption() === this.checkoutLogin()) {
                self.validateRegisteredUser();
              } else {
                self.validateGuestUser();
              }
            }
          };
          
          self.isGiftCardDisabled = ko.computed(function(){
            if(self.approvalRequired()){
              return true;
            }
            else if(self.cart().items().length == 0 || self.amountRemaining()  == 0 || self.isCashPayment() || self.isInvoicePayment() ||
                (self.showSchedule() &amp;&amp; !self.paymentDetails().isGiftCardEnabledForScheduledOrder()) || 
                (self.approvalRequired() &amp;&amp; !self.paymentDetails().isGiftCardEnabledForApproval())) {
              return true;
            }else {
              return false;
            }
          });
          
          self.validateDynamicProperties = function () {
            // clear any previous errors
            notifier.clearError("checkoutDynamicProperties");
            var isValid = true;

            // Dynamic properties are held in the cart view model
            if (!this.cart().validateDynamicProperties() &amp;&amp; !this.errorFlag) {
              this.errorFlag = true;
              notifier.sendError("checkoutDynamicProperties", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
            }
          };

          self.validatePlaceHolderItems = function() {
            // clear any previous errors
            notifier.clearError("placeHolderItems");
            if (this.cart().placeHolderItems().length) {
              if(!this.errorFlag){
                this.errorFlag = true;
                this.placeHolderItemsMsgDisplayed = true;
                notifier.sendWarning("placeHolderItems", CCi18n.t('ns.common:resources.placeHolderItemsErrorMsg'), true);
              }
              // If any change happens in place holder items array, reset the flag so the validation can happen again.
              this.cart().placeHolderItems.subscribe(function() {
                if (this.cart().placeHolderItems().length) {
                  this.placeHolderItemsMsgDisplayed = false;
                }
              }, this);
            }
          };
          
          /**
           * Invokes payment validations/validation-callbacks 
           *     for the selected payment types/ui components.
           */
          self.invokePaymentValidations = function() {
            // If the selected currency is of the type loyaltyPoints, only then try to validate point-related payments.
            if (ccConstants.LOYALTY_POINTS_PAYMENT_TYPE == this.cart().currency.currencyType){
              // validations when loyalty is enabled
              if (this.paymentsViewModel().isLoyaltyEnabled()) {
                if (this.cart().isChargeTaxShippingInSecondaryCurrency()) {
                  // collect tax and shipping in monetary currency
                  if (this.isSplitPayment()) {
                    this.validateSplitPaymentsHandler();
                  } else {
                    //validating checkout-payment-details
                    this.validateCheckoutPaymentDetails();
                    this.validateGiftcards();
                    //validating is any payment method selected for scheduled order
                    this.validatePaymentMethodsForScheduledOrder();
                  }
                }
                //when loyalty is enabled, always call validatePointsPaymentHandler
                if (this.validatePointsPaymentHandler) {
                  this.validatePointsPaymentHandler();
                }
              }
            } else if(this.isSplitPayment()) {
              this.validateSplitPaymentsHandler();
            } else {
              //validating checkout-payment-details 
              this.validateCheckoutPaymentDetails();
              this.validateGiftcards();
              //validating is any payment method selected for scheduled order
              this.validatePaymentMethodsForScheduledOrder();
            }  
          };

          self.reset = function() {
            this.user().reset();
            this.createAccount(false);
            if (this.guestEmailAddress.isModified) {
              this.guestEmailAddress.isModified(false);
            }
            this.guestEmailAddress('');
            self.cart().emailAddressForGuestUser = '';
          };


          self.checkSingleException = function(data){
					if (data.errorCode == ccConstants.CHECKOUT_SESSION_EXPIRED_ERROR) {
              notifier.sendError(ccConstants.CHECKOUT_SESSION_EXPIRED,
              data.message, true);
              return true;
            } else if (data.errorCode == ccConstants.CREATE_ORDER_PRODUCT_NOT_FOUND
                || data.errorCode == ccConstants.CREATE_ORDER_SKU_NOT_FOUND
                || data.errorCode == ccConstants.PRODUCT_NOT_FOR_INDIVIDUAL_SALE) {
              // reload the cart, so that cart is validated and updated
              // accordingly
              notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
              self.cart().loadCart();
              return true;
            } else if (data.errorCode == ccConstants.UNLINKED_ADD_ON_PRODUCT) {
              self.cart().loadCart();
              return true;
            } else if (data.errorCode == ccConstants.ADDON_VOLUME_PRICE_ERROR) {
              var notificationMsg = data.message + " " + CCi18n.t('ns.common:resources.removeItemFromCart');
              notifier.sendError(ORDER_VIEW_MODEL_ID, notificationMsg, true);
            } else if (data.errorCode == ccConstants.INVALID_SHOPPER_INPUT) {
              var moreInfo = JSON.parse(data.moreInfo);
              var invalidAddonProductName = moreInfo.productId;
              var addonProduct = self.cart().findCartProductById(invalidAddonProductName);
              if (addonProduct) {
                invalidAddonProductName = addonProduct.displayName;
              }
              var notificationMsg = CCi18n.t('ns.common:resources.invalidShopperInputError', {productName: invalidAddonProductName});
              notifier.sendError(ORDER_VIEW_MODEL_ID, notificationMsg, true);
            } else if (data.errorCode == ccConstants.ORDER_CANNOT_BE_UPDATED) {
              self.id('');
              var orderError = CCi18n.t('ns.common:resources.orderSubmissionFailed');
              notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
              return true;
            } else if (data.errorCode == ccConstants.COUPON_APPLY_ERROR) {
              // Handle coupon related error
              self.cart().handleCouponPricingError(data, null);
            } else if (data.errorCode == ccConstants.PROCESS_COMPLETION_FAILED_CODE) {
                var orderError = CCi18n.t('ns.common:resources.processCompletionFailed');
                data.message = orderError;
                notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
            } else if (data.errorCode == ccConstants.CONFIGURABLE_PRODUCTS_NOT_ALLOWED_FAILURE_CODE) {
              var orderError = CCi18n.t('ns.common:resources.orderPricingPromotionError');
              data.message = orderError;
              notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
            } else if(data.errorCode == ccConstants.PAYMENT_REVERSAL_FAILED_CODE) {
                self.id('');
                var orderError = CCi18n.t('ns.common:resources.paymentReversalFailed');
                data.message = orderError;
                notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
            } else if (data.errorCode == ccConstants.INVALID_PROFILE_FOR_CHECKOUT) {
                var invalidProfileForCheckoutErrorMessage = CCi18n.t('ns.common:resources.invalidProfileForCheckout');
                data.message = invalidProfileForCheckoutErrorMessage;
                notifier.sendError(ORDER_VIEW_MODEL_ID, invalidProfileForCheckoutErrorMessage, true);
            } else if ( !(data.status == ccConstants.HTTP_UNAUTHORIZED_ERROR) ){
                // We are stopping paypal error messages from being displayed here as
                // they are handled in handleRedirect method after store url changes.
                if (!self.isPaypalVerified()) {
                notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
                return true;
              }
                } else {
                var orderError = CCi18n.t('ns.common:resources.orderSubmissionFailed');
                notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
                return false;
              }
          };

        // Subscribe
        $.Topic(pubsub.topicNames.ORDER_CREATE).subscribe(
            this.createOrder.bind(this));
        $.Topic(pubsub.topicNames.CHECKOUT_EMAIL_ADDRESS).subscribe(
            self.updateEmail);
        $.Topic(pubsub.topicNames.CHECKOUT_BILLING_ADDRESS).subscribe(
            self.updateBillingAddress);
        $.Topic(pubsub.topicNames.CHECKOUT_SHIPPING_ADDRESS).subscribe(
            self.updateShippingAddress);
        $.Topic(pubsub.topicNames.USER_PROFILE_ADDRESSES_REMOVED).subscribe(
            self.resetAddress);
        $.Topic(pubsub.topicNames.CHECKOUT_PAYMENT_DETAILS).subscribe(
            self.updatePaymentDetails);
        $.Topic(pubsub.topicNames.ORDER_CREATED).subscribe(
            this.authPayment.bind(this));
        $.Topic(pubsub.topicNames.PAYMENT_AUTH_SUCCESS).subscribe(
            this.paymentAuthorized.bind(this));
        $.Topic(pubsub.topicNames.PAYMENT_AUTH_DECLINED).subscribe(
            this.paymentDeclined);
        $.Topic(pubsub.topicNames.PAYMENT_AUTH_TIMED_OUT).subscribe(
            this.paymentTimeout);
        $.Topic(pubsub.topicNames.CHECKOUT_SHIPPING_METHOD).subscribe(
            self.updateShippingMethod);
        $.Topic(pubsub.topicNames.ORDER_COMPLETED).subscribe(
            this.clear.bind(this));
        $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).subscribe(
            self.handleRedirect.bind(self));
        $.Topic(pubsub.topicNames.ORDER_SUBMISSION_SUCCESS).subscribe(
            self.handleSubmissionSuccess.bind(self));
        $.Topic(pubsub.topicNames.SCHEDULED_ORDER_SUBMISSION_SUCCESS).subscribe(self.handleScheduledOrderSubmissionSuccess.bind(self));

        // Handle the page change event data to store payerId, token and
        // paymentID
        $.Topic(pubsub.topicNames.PAGE_CHANGED).subscribe(
            self.updatePaymentGatewayData.bind(self));
        // Handle loading of an order
        $.Topic(pubsub.topicNames.PAGE_READY).subscribe(
            self.handlePageReady.bind(self));
        $.Topic(pubsub.topicNames.CONTINUE_TO_PAYPAL).subscribe(
            this.createOrder.bind(this));
        $.Topic(pubsub.topicNames.USER_LOGOUT_SUCCESSFUL).subscribe(
            this.resetAddress.bind(this));
        $.Topic(pubsub.topicNames.USER_LOGOUT_SUCCESSFUL).subscribe(
            this.resetOrderId.bind(this));
        $.Topic(pubsub.topicNames.USER_LOGIN_SUCCESSFUL).subscribe(
            this.resetOrderId.bind(this));
        $.Topic(pubsub.topicNames.GIFTCARD_UPDATE_FROM_CART).subscribe(this.updateGiftCards.bind(this));
        $.Topic(pubsub.topicNames.UPDATE_AMOUNT_REMAINING).subscribe(this.updateAmountRemaining.bind(this));
        $.Topic(pubsub.topicNames.UPDATE_AMOUNT_REMAINING_PENDING_PAYMENT).subscribe(this.updateAmountRemainingPendingPayment.bind(this));
        $.Topic(pubsub.topicNames.USER_CREATION_FAILURE).subscribe(this.createOrderAfterRegistration.bind(this));
        $.Topic(pubsub.topicNames.AUTO_LOGIN_AND_GET_USER_DATA_SUCCESSFUL).subscribe(this.createOrderAfterRegistration.bind(this));
        $.Topic(pubsub.topicNames.USER_AUTO_LOGIN_FAILURE).subscribe(this.createOrderAfterRegistration.bind(this));
        $.Topic(pubsub.topicNames.USER_PROFILE_UPDATE_SUCCESSFUL).subscribe(this.createOrderAfterProfileUpdate.bind(this));
        $.Topic(pubsub.topicNames.USER_PROFILE_UPDATE_NOCHANGE).subscribe(this.createOrderAfterProfileUpdate.bind(this));
        $.Topic(pubsub.topicNames.USER_PROFILE_UPDATE_INVALID).subscribe(this.createOrderAfterProfileUpdate.bind(this));
        $.Topic(pubsub.topicNames.USER_PROFILE_UPDATE_FAILURE).subscribe(this.createOrderAfterProfileUpdate.bind(this));
        $.Topic(pubsub.topicNames.CART_PRICE_COMPLETE).subscribe(this.disablePaymentIfNecessary.bind(this));


        return (self);
      }

      /**
       * Returns true if the payments are disabled.
       * @function OrderViewModel#isPaymentsDisabled
       */
      OrderViewModel.prototype.isPaymentsDisabled = function(){
          var self = this;
          //This can be extended to add any rules/conditions which require disabling payment gateways.
          var total = self.cart().getDerivedTotal(self.cart().secondaryCurrencyTotal(), self.cart().total());
          var disableRules = total == 0;
          if(disableRules){
             $.Topic(pubsub.topicNames.PAYMENTS_DISABLED).publish();
          }
          return disableRules;
       }

      /**
       * Returns true if the point-based payments are disabled.
       * @function OrderViewModel#isPointPaymentsDisabled
       */
      OrderViewModel.prototype.isPointPaymentsDisabled = function(){
          var self = this;
          //This can be extended to add any rules/conditions which require disabling payment gateways.
          var total = self.cart().getDerivedTotal(self.cart().primaryCurrencyTotal(), self.cart().total());
          var disableRules = total == 0;
          return disableRules;
       }

      /** Updates the gift cards array 
       * with the applied gift cards
       */
      OrderViewModel.prototype.updateGiftCards = function(pGiftCards) {
        var self = this;
        self.giftCards([]);
        for ( var i = 0; i &lt; pGiftCards.length; i++) {
          var giftCardPayment = pGiftCards[i];
          self.giftCards.push(giftCardPayment);
        }
      };

      /**
       * this method updates remaining amount on the order
       */
      OrderViewModel.prototype.updateAmountRemaining = function(
          pAmountRemaining) {
        var self = this;
        self.amountRemaining(pAmountRemaining);
      };
      OrderViewModel.prototype.updateAmountRemainingPendingPayment = function(
          pAmountRemaining) {
        var self = this;
        var tempAmount=self.amountRemaining()+pAmountRemaining;
        self.amountRemaining(tempAmount);
      };

      

      OrderViewModel.prototype.createOrderAfterRegistration = function(data) {
        if (this.registerUser &amp;&amp; !(!this.contextData.global.guestCheckoutEnabled &amp;&amp;
            data &amp;&amp; data.errorCode === ccConstants.CREATE_PROFILE_USER_EXISTS)) {
          this.createOrder();
          this.registerUser = false;
        }
        else {
          this.destroySpinner();
          this.enableOrderButton(true);
          this.registerUser = false;
          if (data) {
            notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
		  }

          // Remove the registration failure from the stored values. This ensures that
          // it doesn't get incorrectly captured by the confirmation page once the user
          // places the order with a valid email address.
          if (ccRestClient.getStoredValue(ccConstants.PAYULATAM_CHECKOUT_REGISTRATION) ===
        	  ccConstants.PAYULATAM_CHECKOUT_REGISTRATION_FAILURE) {

            ccRestClient.clearStoredValue(ccConstants.PAYULATAM_CHECKOUT_REGISTRATION);
          }
        }
      };
      
      /**
       * this method creates a order after update profile call.
       */
      OrderViewModel.prototype.createOrderAfterProfileUpdate = function() {
        if (this.user &amp;&amp; !this.user().isUserSessionExpired()) {
          if (this.placeOrder) {
        	  if(this.cart().currentOrderState() == ccConstants.PENDING_PAYMENTS || 
        	     this.cart().currentOrderState() == ccConstants.PENDING_PAYMENT_TEMPLATE){
        	  		if(this.isSplitPayment()) {
        	  			this.invokePaymentsAPIHandler();
        	  		} else {
        	  			this.addPaymentsToOrder();
        	  		}
              }
              else {
            	  this.createOrder();
              }
            this.enableOrderButton(true);
            this.placeOrder = false;
          }
          this.destroySpinner();
        } else {
          this.enableOrderButton(true);
          this.destroySpinner();
        }
      };

      OrderViewModel.prototype.handleSubmissionSuccess = function(data) {
        var self = this;
        if(self.restClient.profileType === ccConstants.PROFILE_TYPE_AGENT) {
           //Adding parameter isScheduleOrder = true, to differentiate between normal and schedule order when page is refreshed
          //so that getOrder or getScheduleOrder can be made.
          navigation.goTo(this.contextData.global.links.AgentOrderDetails.route +'/'+ (data[0].scheduledId ? (data[0].scheduledId +'?' + ccConstants.AGENT_PARAM_IS_SCHEDULED_ORDER + '=true')
            :data[0].id));
        } else {
          navigation.goTo(this.contextData.global.links.confirmation.route +'/'+ data[0].uuid);
        }
        self.isOrderSubmitted = true;
        self.approvalRequired(false);
        self.enableOrderButton(true);
        if (self.isPaypalVerified()) {
          self.clearPaypalData();
        }
        if (!self.user().loggedIn()) {
          self.reset();
        }
      };
      
      /**
       * Callback for schedule order submit success
       * Redirects to schedule order details page
       */
      OrderViewModel.prototype.handleScheduledOrderSubmissionSuccess = function(data) {
        var self = this;
        if(self.restClient.profileType === ccConstants.PROFILE_TYPE_AGENT) {
          //Adding parameter isScheduleOrder = true, to differentiate between normal and schedule order when page is refreshed
          //so that getOrder or getScheduleOrder can be made.
          navigation.goTo(this.contextData.global.links.AgentOrderDetails.route +'/'+ data[0].scheduleOrderId + '?' + ccConstants.AGENT_PARAM_IS_SCHEDULED_ORDER + '=true');
        } else {
          navigation.goTo(this.contextData.global.links.scheduledOrders.route + "/" + data[0].scheduleOrderId);
        }
        
        self.isOrderSubmitted = true;
        self.enableOrderButton(true);
        if (self.isPaypalVerified()) {
          self.clearPaypalData();
        }
        if (!self.user().loggedIn()) {
          self.reset();
        }
        this.destroySpinner();
      };

      /**
       * Redirects to the checkout page if the page is not checkout.
       * @private
       * @function OrderViewModel.handleRedirect
       * @param {OrderViewModel} data Order data.
       */
      OrderViewModel.prototype.handleRedirect = function(data) {
        var self = this;
        self.enableOrderButton(true);
        var navPath=navigation.getPathWithoutLocale().split("?");
        if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
          if(self.order() &amp;&amp; (self.order().state=="PENDING_PAYMENT" || self.order().state == ccConstants.PENDING_PAYMENT_TEMPLATE)) {
            self.contextManager.getInstance().setProperty(ccConstants.IS_PENDING_PAYMENT, true);
            self.contextManager.getInstance().includedAgentContextProperties.push(ccConstants.IS_PENDING_PAYMENT);
            var context = self.contextManager.getInstance().export();
            navPath[0] = (self.agentCheckoutLink+ "?orderId=" + self.order().id+ '&amp;context='+ encodeURIComponent(context));
          }
          else{
            var url = self.agentCheckoutLink;
            var context = self.contextManager.getInstance().export();
            url = url+'?context='+ encodeURIComponent(context);
            navPath[0] = url;
          }
          navigation.goTo(navPath[0]);
         }
        else {
          // As order creation can fail at cart page if checkout with paypal is
          // clicked
          if (navigation.getPathWithoutLocale() == self.cartLink &amp;&amp; (self.isPaypalVerified() ||
              self.cart().checkoutWithPaypalClicked())) {
            navigation.goTo(self.cartLink);
          }
          else if (navigation.getPathWithoutLocale() == self.checkoutLink &amp;&amp; self.isPaypalVerified()) {
             navigation.goTo(self.checkoutLink);
          }
          else {
              if((navPath[0] == self.checkoutLink) &amp;&amp; (navigation.getPathWithoutLocale().indexOf('orderId=')!= -1)){
                navigation.goTo(navigation.getPathWithoutLocale());
              }
              else{
                navigation.goTo(self.checkoutLink);
              }
            }
          if (data.data &amp;&amp; (self.isPaypalVerified() || self.cart().checkoutWithPaypalClicked())) {
            notifier.sendErrorToPage(ccConstants.PAYPAL_PLACE_ORDER_ERROR,
            data.data.message, true, 'checkout', true);
          }
          if (self.isPaypalVerified() || self.cart().checkoutWithPaypalClicked()) {
            self.clearPaypalData();
         }
       }
      };

      /**
       * Perform appropriate validations when checkout with paypal is clicked.
       * @private
       * @function OrderViewModel.handleCheckoutWithPaypal
       */
      OrderViewModel.prototype.handleCheckoutWithPaypal = function() {
        var self = this;
        // Clearing 'Pay By Cash' option.
        self.cashModel().isPayingByCash(false);
        // Email address is mandatory if user enters shipping address on
        // checkout page
        if (self.shippingAddress() &amp;&amp; self.shippingAddress().address1()
            &amp;&amp; !self.emailAddress() &amp;&amp; navigation.getPathWithoutLocale() == self.checkoutLink
            &amp;&amp; !self.user().loggedIn()) {
          $.Topic(pubsub.topicNames.PAYPAL_EMAIL_VALIDATION).publishWith(self,
              [ {
                message : "fail"
              } ]);
        } else {
          self.continueCheckoutWithPaypal();
        }
      };

      /**
       * Continue checkout with PayPal.
       * Called after initial validation on shipping address and email address.
       * @private
       * @function OrderViewModel.continueCheckoutWithPaypal
       */
      OrderViewModel.prototype.continueCheckoutWithPaypal = function() {
        var self = this;
        if (!self.cart().shippingMethod() &amp;&amp; self.shippingAddress() &amp;&amp; self.shippingAddress().validateForShippingMethod()) {
          storageApi.getInstance().setItem("checkoutAddressWithoutShippingMethod", JSON.stringify(self.shippingAddress().toJSON()));
        }
        if (self.guestEmailAddress() ){
          storageApi.getInstance().setItem("guestEmailAddress", self.guestEmailAddress());
        }
        self.updatePaypalPaymentType(ccConstants.PAYPAL_CHECKOUT_TYPE);
        // this flag tells us whether checkout with paypal was clicked
        self.cart().checkoutWithPaypalClicked(true);
        self.cart().skipPriceChange(true);
        
        self.cart().handleValidateCart();
        // To clear order id as initial call to create order should not have
        // order id
        self.id(null);
        self.op(ccConstants.ORDER_OP_INITIATE);
      };

      /**
       * Clear down order details.
       * @private
       * @function OrderViewModel.clear
       */
      OrderViewModel.prototype.clear = function() {
        var self = this;
        self.id(null);
        self.emailAddress('');
        self.order(null);
        self.orderProfileId(null);
        self.selectedShippingOption(null);
        self.op(null);
        self.giftCards([]);
        self.isInvoicePayment(false);
        self.isPayLater(false);
        self.poNumber('');
        self.enableOrderButton(true);
        self.createAccount(false);
        if (self.guestEmailAddress.isModified) {
          self.guestEmailAddress.isModified(false);
        }
        self.guestEmailAddress('');
        self.checkoutOption(ccConstants.GUEST);
        self.isOrderLocked = false;
        self.isOrderSubmitted = false;
        self.payments([]);
        self.amountRemaining(null);
        self.approvalRequired(false);
        self.isAutherizeCalled = false;
        self.loadedOrderShippingAddress = null;
        self.cart().currentOrderId(null);
        self.cart().currentOrderState(null);
        
        
        //Clear edit order related fields
        if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT &amp;&amp; self.user().clonedOrderId()) {
          self.clearCloneOrderData();
          self.paymentsViewModel().resetPaymentsContainer();
          self.paymentsViewModel().totalAmountAuthorized(0);
          self.paymentsViewModel().totalAmountAuthorizedOnVoid(0);
          self.cart().emptyCart();
          if(self.contextManager) {
            self.contextManager.getInstance().clearAgentContext();
          }
        }
      };
      
      /**
       * Clear down paypal payment details.
       * @private
       * @function OrderViewModel.clearPaypalData
       */
      OrderViewModel.prototype.clearPaypalData = function() {
        var self = this;
        self.paymentGateway(new PaypalPaymentDetails());
        self.cart().checkoutWithPaypalClicked(false);
        self.isPaypalVerified(false);
        self.id(null);
        self.op(null);
      };

      /**
       * Get order details of initial order created during checkout with paypal.
       * On success, publish the PAYPAL_CHECKOUT_SHIPPING_ADDRESS topic, with
       * the shipping address retrieved from the order.
       * @private
       * @function OrderViewModel.getOrder
       */
      OrderViewModel.prototype.getOrder = function() {
        var self = this;
        self.giftCards([]);
        self.cart().giftCards([]);
        self.cart().dynamicProperties([]);
        var paymentType = self.paymentGateway().type;
        var params = {};
        if (self.paymentGateway().type == ccConstants.PAYPAL_CHECKOUT_TYPE) {
          params[ccConstants.PAYER_ID] = self.paymentGateway().PayerID;
          params[ccConstants.TOKEN] = self.paymentGateway().token;
          params[ccConstants.PAYMENT_ID] = self.paymentGateway().paymentId;
        } else if (self.paymentGateway().type == ccConstants.PAYULATAM_CHECKOUT_TYPE) {
          params[ccConstants.AMOUNT] = self.paymentGateway().amount;
          params[ccConstants.CURRENCY] = self.paymentGateway().currency;
          params[ccConstants.PAYMENT_ID] = self.paymentGateway().paymentId;
          params[ccConstants.TRANSACTION_STATUS] = self.paymentGateway().transactionStatus;
          params[ccConstants.TRANSACTION_TYPE] = self.paymentGateway().transactionType;
          params[ccConstants.SIGNATURE] = self.paymentGateway().signature;
        } else if (self.payments().length > 0) {
          // take the first in the list for the payment type
          paymentType = self.payments()[0].type;
          if (self.payments()[0].customProperties) {
            params.customProperties = self.payments()[0].customProperties;
          }
        }
        var contextObj = {};
        contextObj[ccConstants.ENDPOINT_KEY] = ccConstants.ENDPOINT_GET_INITIAL_ORDER;
        contextObj[ccConstants.IDENTIFIER_KEY] = "getOrder";
        var filterKey = self.storeConfiguration.getFilterToUse(contextObj);
        if (filterKey) {
          params[ccConstants.FILTER_KEY] = filterKey;
        }
        self.adapter.loadJSON(ccConstants.ENDPOINT_GET_INITIAL_ORDER,
            paymentType, params,
            // success callback
            function(data) {
              //As the CartViewModel is reset on redirection, update the cart with server data.
              var isUserLoggedIn = self.user() &amp;&amp; self.user().loggedIn() ? true : false;
              var cartItems;
              if(data.shoppingCart &amp;&amp; data.shoppingCart.items){
                cartItems = data.shoppingCart.items;
              }
              if (isUserLoggedIn) {
                self.cart().emptyCart();
                self.cart().mergeItems(data);
                self.cart().updateCartData(data, false, isUserLoggedIn);
                self.cart().cartUpdated();
              } else {
                self.cart().loadCart();
                var guestEmailAddress = storageApi.getInstance().getItem("guestEmailAddress");
                if(guestEmailAddress){
                  self.guestEmailAddress(guestEmailAddress);
                  storageApi.getInstance().removeItem("guestEmailAddress");                  
                }
              }
			  if (data.state == ccConstants.PENDING_PAYMENT ||
			      data.state == ccConstants.PENDING_PAYMENT_TEMPLATE) {
        	    self.cart().currentOrderState(data.state);
        	    self.cart().currentOrderId(data.id);
                self.cart().orderCurrency=data.priceListGroup.currency;
                self.cart().orderItems(data.shoppingCart.items);
                var amountRemaining = self.cart().getDerivedTotal(data.priceInfo.secondaryCurrencyTotal, data.priceInfo.total);
                self.amountRemaining(amountRemaining);
                self.isAutherizeCalled=true;
                self.isOrderEditable(false);
              }
			  if (data.state == ccConstants.QUOTED_STATES ) {
	            self.cart().currentOrderState(data.state);
	        	self.cart().currentOrderId(data.id);
	            self.cart().orderCurrency=data.priceListGroup.currency;
	            self.cart().orderItems(data.shoppingCart.items);
	            self.isOrderEditable(false);
			  }
              if (data.state == ccConstants.INCOMPLETE_CANCEL) {
                self.cart().currentOrderState(data.state);
                self.cart().currentOrderId(data.id);
                self.cart().orderCurrency = data.priceListGroup.currency;
                self.cart().orderItems(data.shoppingCart.items);
                self.isOrderEditable(false);
              }
              if (self.isPaypalVerified()) {
                self.id(data.id);
                var paymentGroups = data.payments;
                var paymentGpId = "";
                
                for (var i=0 ; i&lt;paymentGroups.length ; i++) {
                  if (paymentGroups[i] &amp;&amp; paymentGroups[i].type == ccConstants.PAYPAL_CHECKOUT_TYPE) {
                    paymentGpId = paymentGroups[i].paymentGroupId;
                    var paymentDetails = new PaypalPaymentDetails(ccConstants.PAYPAL_CHECKOUT_TYPE, 
                    self.paymentGateway().paymentId, self.paymentGateway().token, self.paymentGateway().PayerID, paymentGpId);
                    self.paymentGateway(paymentDetails);
                    self.paymentsViewModel().paypalPaymentGroupId(paymentGpId);
                  }
                }
                var savedShippingAddressWithoutMethod = storageApi.getInstance().getItem("checkoutAddressWithoutShippingMethod");
               
                $.Topic(pubsub.topicNames.PAYPAL_CHECKOUT_SHIPPING_ADDRESS)
                    .publish(data.shippingAddress);
                $.Topic(pubsub.topicNames.EXTERNAL_CHECKOUT_BILLING_ADDRESS)
                    .publish(data.billingAddress);
                
                // To set the shipping method selected by the user
                if (data.shippingMethod &amp;&amp; !savedShippingAddressWithoutMethod) {
                  $.Topic(pubsub.topicNames.PAYPAL_CHECKOUT_SHIPPING_METHOD_VALUE)
                      .publishWith(data.shippingMethod.value);
                } else {
                  $.Topic(pubsub.topicNames.PAYPAL_CHECKOUT_NO_SHIPPING_METHOD)
                      .publish();
                }
                
                // Dynamic properties
                if (data.dynamicProperties) {
                  self.cart().updateDynamicProperties(data);
                }
                
                var total = data.priceInfo.secondaryCurrencyTotal ? data.priceInfo.secondaryCurrencyTotal : data.priceInfo.total;
                if (paymentGroups.length == 1 
                    &amp;&amp; paymentGroups[0] &amp;&amp; paymentGroups[0].type == ccConstants.PAYPAL_PAYMENT_TYPE
                    &amp;&amp; paymentGroups[0].amount != total) {
                  var reappyGcs = CCi18n.t('ns.common:resources.reapplyGIftCards');
                  notifier.sendError("GC", reappyGcs, true);
                }
              } else if (self.paymentGateway().type == ccConstants.PAYULATAM_CHECKOUT_TYPE) {
                if (data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_APPROVED || 
                    data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_PENDING ||
                    data.payments[0].paymentState == ccConstants.PAYMENT_GROUP_STATE_SETTLED) {
                  $.Topic(pubsub.topicNames.ORDER_SUBMISSION_SUCCESS).publish([{
                      message : "success",
                      id : data.id,
                      uuid : data.uuid,
                      items : cartItems
                  }]);
                } else if (data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_DECLINED || 
                  data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_EXPIRED || 
                  data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_ERROR) {
                  $.Topic(pubsub.topicNames.WEB_CHECKOUT_SHIPPING_ADDRESS)
                    .publish(data.shippingAddress);
                  // To set the shipping method selected by the user
                  if (data.shippingMethod) {
                    self.webCheckoutShippingMethodValue = data.shippingMethod.value;
                  }
                  if (!self.user().loggedIn() &amp;&amp; data.shippingAddress.email) {
                    self.guestEmailAddress(data.shippingAddress.email);
                  }
                  var payUNotifierMsg = "";
                  if (data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_DECLINED) {
                    payUNotifierMsg = CCi18n.t('ns.common:resources.paymentDeclinedMsg');
                  } else if (data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_EXPIRED) {
                    payUNotifierMsg = CCi18n.t('ns.common:resources.paymentExpiredMsg');
                  } else if (data.payments[0].transactionStatusByQuery == ccConstants.PAYU_TRANSACTION_ERROR) {
                    payUNotifierMsg = CCi18n.t('ns.common:resources.paymentErrorMsg');
                  }
                  ccRestClient.clearStoredValue(ccConstants.PAYULATAM_CHECKOUT_REGISTRATION);
                  if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
                    navigation.goTo(self.agentCheckoutLink);
                  }
                  else {
                    navigation.goTo(self.checkoutLink);
                  }
                  notifier.sendErrorToPage(ORDER_VIEW_MODEL_ID, payUNotifierMsg, true, 'checkout', true);
                  $("#CC-messages").attr("aria-live","assertive");
                }
                self.paymentGateway(null);
                self.destroySpinner();
              }
              $.Topic(pubsub.topicNames.ORDER_RETRIEVED_INITIAL).publishWith(data, [{
                message : "success",
                order : data
              }]);
            },
            // error callback
            function(data) {
              self.destroySpinner();
              self.clearPaypalData();
              self.paymentGateway(null);
              self.payments([]);
              $.Topic(pubsub.topicNames.GET_INITIAL_ORDER_FAIL).publish([{message: "fail"}]);
              notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
            });
      };
      
          /**
           * Update an order.
           * &lt;p>
           * Build up a list of OrderItems, from the existing cart ({@link CartViewModel}). Create an
           * (internal) ShoppingCart object with these items, along with any coupons from the cart,
           * and finally create an Order object, from the cart and the payment details.
           * Send this Order object to the endpoint to submit the order.
           * @private
           * @function OrderViewModel.addPaymentsToOrder
           */
          OrderViewModel.prototype.addPaymentsToOrder = function() {
            var self = this;
            var billingAddress = undefined;
            if (self.billingAddress()) {
              billingAddress = self.billingAddress().toJSON();
            }
            
            var op = '';
            if (self.op() == ccConstants.ORDER_OP_INITIATE) {
            	op = self.op();
            }
            else{
           	 var paymentGroup= storageApi.getInstance().getItem(ccConstants.PAYMENT_GROUP_AFTER_PAYPAL);
            }

             var payments = [];
             if(!self.isSplitPayment()){
               // If the selected currency is of the type loyaltyPoints, only then try to add the point-based payments
               if (ccConstants.LOYALTY_POINTS_PAYMENT_TYPE == self.cart().currency.currencyType) {
                 if (self.paymentsViewModel().isLoyaltyEnabled()) {
                   var tempPayments = self.paymentsViewModel().preparePaymentsRequest(self.paymentsViewModel().pendingPayments());
                   // TODO: Revisit this condition when split shipping is supported with loyalty.
                   for (var i=0; i&lt;tempPayments.length; i++) {
                     if (tempPayments[i].paymentMethodType == ccConstants.LOYALTY_POINTS_PAYMENT_TYPE) {
                       // Here, though we have supported split payments with loyalty, the loyalty payment can't be splitted again.
                       // Hence we can associate the primaryCurrencyTotal or the orderTotal to the loyalty payments amount, if they
                       // are not already present.
                       if (tempPayments[i].amount &amp;&amp; null == tempPayments[i].amount) {
                         var total = self.cart().getDerivedTotal(self.cart().primaryCurrencyTotal(), self.cart().total());
                         tempPayments[i].amount = total;
                       }
                       if (tempPayments[i].billingAddress &amp;&amp; null == tempPayments[i].billingAddress) {
                         tempPayments[i].billingAddress = billingAddress;
                       }
                       payments.push(tempPayments[i]);
                     }
                   }
                 }
               }
             }
            if (self.cashModel().isPayingByCash()) {
              var payment = {};
              payment.paymentMethodType = ccConstants.CASH_PAYMENT_TYPE;
              if(self.cashModel().customProperties &amp;&amp; (Object.keys(self.cashModel().customProperties).length - 1) > 0) {
                payment.customProperties = ko.mapping.toJS(self.cashModel().customProperties);
              }
              payment.billingAddress = billingAddress;
              payment.amount=self.amountRemaining();
              payments.push(payment);
              op = ccConstants.ORDER_OP_INITIATE;
            } else {        
              //Gift Cards
              if (self.giftCards()) {
                for ( var i = 0; i &lt; self.giftCards().length; i++) {
                  var payment = {};
                  payment.paymentMethodType = ccConstants.GIFT_CARD_PAYMENT_TYPE;
                  payment.giftCardNumber = self.giftCards()[i].giftCardNumber();
                  payment.giftCardPin = self.giftCards()[i].giftCardPin();
                  if (!self.giftCards()[i].isAmountRemaining() || self.isPaypalVerified()) {
                    payment.amount = self.giftCards()[i].amountUsed();
                  }
                  payment.paymentGroupId = self.giftCards()[i].paymentGroupId;
                  if(self.giftCards()[i].customProperties &amp;&amp; (Object.keys(self.giftCards()[i].customProperties).length - 1) > 0) {
                    payment.customProperties = ko.mapping.toJS(self.giftCards()[i].customProperties);
                  }
                  payment.amount=self.giftCards()[i].amountUsed();
                  payment.billingAddress = billingAddress;
                  payments.push(payment);
                }
              }
              if (self.payments().length > 0) {
                // Add any generic payments.
                ko.utils.arrayForEach(self.payments(), function (payment) {
                    payment.billingAddress = billingAddress;
                    if(payment.type){
                      payment.paymentMethodType = payment.type;
                      delete payment.type;
                    }
                    payments.push(payment);
                });
              } 
              // These entries are for Paypal and credit card respectively. Update here
              // for other payment scenarios.
              else if (self.isPaypalVerified() || (self.amountRemaining &amp;&amp; self.amountRemaining() != 0)) {
                if (self.paymentGateway() &amp;&amp; self.paymentGateway().type) {
                  var payment = {};
                  payment.paymentMethodType = self.paymentGateway().type;
                  payment.billingAddress = billingAddress;
                  if(op=='' &amp;&amp; self.paymentGateway().type == ccConstants.PAYPAL_CHECKOUT_TYPE){
                      payment.PayerID = self.paymentGateway().PayerID;
                      payment.token = self.paymentGateway().token;
                      payment.paymentId = self.paymentGateway().paymentId;
                      payment.paymentGroupId = paymentGroup;
                  }
                  else if(self.paymentGateway().type == ccConstants.PAYULATAM_CHECKOUT_TYPE){
                	  payment.currency = self.paymentGateway().currency;
                  }
                  payment.amount=self.amountRemaining();
                  payments.push(payment);
                  self.createSpinner();
                } else if(self.isInvoicePayment()) {
                	var payment = {};
                    payment = {paymentMethodType:ccConstants.INVOICE_PAYMENT_TYPE, PONumber:self.poNumber()};
                    payment.billingAddress = billingAddress;
                    payment.amount=self.amountRemaining();
                    payments.push(payment);
                } else if (self.paymentDetails &amp;&amp; self.paymentDetails() &amp;&amp; self.paymentDetails().isModified()) {
                  var payment = {};
                    payment = new CreditCardPaymentDetailsClientSide(self.paymentDetails());
                    if(self.paymentDetails().customProperties &amp;&amp; (Object.keys(self.paymentDetails().customProperties).length - 1) > 0) {
                    payment.customProperties = ko.mapping.toJS(self.paymentDetails().customProperties);
                    }
                    
                  payment.paymentMethodType = ccConstants.CARD_PAYMENT_TYPE;
                  
                  payment.billingAddress = billingAddress;
                  payment.amount=self.amountRemaining();
                  payments.push(payment);
                }
              }
              
            }
 
            // check if OrderViewModel has order id and the user is logged-in to
            // reuse the order to update and submit with changes.
            if (self.user() &amp;&amp; self.user().orderId()
                &amp;&amp; self.user().loggedIn()
                &amp;&amp; !self.hasPaymentType(ccConstants.GENERIC_PAYMENT_TYPE)) {
                       	
            	 var url = "addPayments";
            	 var inputData = {};
                 inputData["orderId"] = self.user().orderId();
                 if(op != ""){
                	 inputData["op"] = op; 
                 }
                 var profileId = self.user().id();
                 if(ccRestClient.profileType != ccConstants.PROFILE_TYPE_AGENT){
                   inputData["profileId"] = profileId;
                 }
                 else{
                   if(profileId) {
                     inputData["profileId"] = profileId;
                   }
                 }
                 inputData["payments"] = payments;
              // Update the order
                 ccRestClient.request(url, inputData,
                  // success callback
                  function(data) {
                    self.postPaymentOrderUpdateSuccess(data);
                  },
                  // error callback
                  function(data) {
                    var param = new Object();
                 
                      param.orderId = self.id();
                      param.errorCode = data.errorCode;
                    
                    self.storeServerLog.logError("updateOrderFailure",self.storeServerLog.getMessage("updateOrderFailure", param));
                    self.postOrderCreateOrUpdateFailure(data);
                  });
            } else {
            	if(!this.user().isB2BUser()) {
            		var url = "addPayments";
             	 	var inputData = {};
                inputData["orderId"] = self.user().orderId();
                if(op != ""){
                 	inputData["op"] = op; 
                }
                inputData["uuid"] = self.order().uuid;
                inputData["payments"] = payments;
                if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
                  var profileId = self.user().id();
                  if(profileId){
                    inputData["profileId"] = profileId;
                  }
                }
                // Update the order
                ccRestClient.request(url, inputData,
                  // success callback
                  function(data) {
                    self.postPaymentOrderUpdateSuccess(data);
                  },
                  // error callback
                  function(data) {
                    var param = new Object();
                  
                    param.orderId = self.id();
                    param.errorCode = data.errorCode;
                     
                    self.storeServerLog.logError("updateOrderFailure",self.storeServerLog.getMessage("updateOrderFailure", param));
                    self.postOrderCreateOrUpdateFailure(data);
                  });
            	}
            }
          };
       
      /**
       * Create an order.
       * &lt;p>
       * Build up a list of OrderItems, from the existing cart ({@link CartViewModel}). Create an
       * (internal) ShoppingCart object with these items, along with any coupons from the cart,
       * and finally create an Order object, from the cart and the payment details.
       * Send this Order object to the endpoint to submit the order.
       * @private
       * @function OrderViewModel.createOrder
       */
      OrderViewModel.prototype.createOrder = function() {
        this.cart().isOrderSubmissionInProgress = true;
        if(this.cart().currentOrderState()== ccConstants.PENDING_PAYMENTS ||
           this.cart().currentOrderState()== ccConstants.PENDING_PAYMENT_TEMPLATE){
        	if(this.isSplitPayment()) {
        		this.invokePaymentsAPIHandler();
        	} else {
        		this.addPaymentsToOrder();
        	}
        } else {
        var self = this;
        
        var items = ko.observableArray([]);
        var giftWithPurchaseOrderMarkers = self.cart().giftWithPurchaseOrderMarkers;
        var cartItems = self.cart().items;
        for (var i = 0; i &lt; cartItems().length; i++) {
          var cartItem = new OrderItem(cartItems()[i]);

          if (cartItems()[i].childItems) {
            cartItem.childItems = cartItems()[i].childItems;
            cartItem.configuratorId = cartItems()[i].configuratorId;
          }
          for(var j = 0; j &lt; self.cart().lineAttributes().length; j++) {
            cartItem[self.cart().lineAttributes()[j].id()] = cartItems()[i][self.cart().lineAttributes()[j].id()];
          }
          items.push(cartItem);
        }

        var shoppingCart = new ShoppingCart(items, self.cart().coupons(), self
            .cart().total());

        var shippingGroups;
        shippingGroups = self.cart().createShippingGroups();

        var schedule = undefined;
        
        if (self.showSchedule() &amp;&amp; self.schedule()) {
          schedule = self.schedule().toJSON();
        }

        var shippingAddress = undefined;
        if (self.shippingAddress()) {
          if (self.paymentGateway() &amp;&amp; self.paymentGateway().type === ccConstants.PAYPAL_CHECKOUT_TYPE &amp;&amp;
            navigation.isPathEqualTo(self.cartLink)) {
            var paypalShippingCheck = self.shippingAddress().isValid();
            if (paypalShippingCheck) {
              shippingAddress = self.shippingAddress().toJSON();
            }
          }
          else {
            shippingAddress = self.shippingAddress().toJSON();
          }
        }
       
        var billingAddress = undefined;
        if (self.billingAddress()) {
          billingAddress = self.billingAddress().toJSON();
        }

        var isAnonymousCheckout = true;
        if (self.user().loggedIn()) {
          isAnonymousCheckout = false;
          if (!self.emailAddress() &amp;&amp; self.user().emailAddress()) {
            self.emailAddress(self.user().emailAddress());
          }
        }

        if (self.emailAddress()) {
          var emailAddress = self.emailAddress().toString();

          if (shippingGroups) {
            // update the email address on shipping address of each shipping group
            shippingGroups.forEach(function(shippingGroup){
              if (shippingGroup.shippingAddres) {
                shippingGroup.shippingAddress.email = emailAddress;
              } else {
                shippingGroup.email = emailAddress;
              }
            });
          } else if (shippingAddress) {
            shippingAddress.email = emailAddress;
          }
        }

        var appliedPromotions = [];
        for (var i = 0; i &lt; self.cart().orderDiscountDescList().length; i++) {
          appliedPromotions
              .push(self.cart().orderDiscountDescList()[i].promotionId);
        }

        for (var couponIndex = 0; couponIndex &lt; self.cart().claimedCouponMultiPromotions().length; couponIndex++) {
          for(var promoIndex = 0; promoIndex &lt; self.cart().claimedCouponMultiPromotions()[couponIndex].promotions().length; promoIndex++) {
            appliedPromotions
              .push(self.cart().claimedCouponMultiPromotions()[couponIndex].promotions()[promoIndex].promotionId());
          }
        }
        
        var payments = [];
        if(!self.isPayLater()) {
          // If the selected currency is of the type loyaltyPoints, only then add the point-based payments
          if (ccConstants.LOYALTY_POINTS_PAYMENT_TYPE == self.cart().currency.currencyType) {
            if (self.paymentsViewModel().isLoyaltyEnabled()) {
              var tempPayments = self.paymentsViewModel().preparePaymentsRequest(self.paymentsViewModel().pendingPayments());
              // TODO: Revisit this condition when split shipping is supported with loyalty.
              for (var i=0; i&lt;tempPayments.length; i++) {
                if (tempPayments[i].paymentMethodType == ccConstants.LOYALTY_POINTS_PAYMENT_TYPE) {
                  // Here, though we have supported split payments with loyalty, the loyalty payment can't be splitted again.
                  // Hence we can associate the primaryCurrencyTotal or the orderTotal to the loyalty payments, if they
                  // are not already present.
                  if (tempPayments[i].amount &amp;&amp; null == tempPayments[i].amount) {
                    var total = self.cart().getDerivedTotal(self.cart().primaryCurrencyTotal(), self.cart().total());
                    tempPayments[i].amount = total;
                  }
                  if (tempPayments[i].billingAddress &amp;&amp; null == tempPayments[i].billingAddress) {
                    tempPayments[i].billingAddress = billingAddress;
                  }
                  payments.push(tempPayments[i]);
                }
              }
            }
          }

          if (self.isSplitPayment()) {
              var tempPayments = self.paymentsViewModel().preparePaymentsRequest(self.paymentsViewModel().pendingPayments());
              for (var i=0; i&lt;tempPayments.length; i++) {
                if (tempPayments[i].paymentMethodType == ccConstants.CARD_PAYMENT_TYPE &amp;&amp; self.isCardPaymentClientSide) {
                  payments.push({type:"card", amount:tempPayments[i].amount, seqNum:tempPayments[i].seqNum});
                } else if (tempPayments[i].paymentMethodType == ccConstants.PAYPAL_CHECKOUT_TYPE) {
                  if (self.paymentsViewModel().paypalPaymentGroupId() &amp;&amp; tempPayments[i].token){
                    tempPayments[i].paymentGroupId = self.paymentsViewModel().paypalPaymentGroupId();
                  }
                  payments.push(tempPayments[i]);
                } else if (tempPayments[i].paymentMethodType == ccConstants.LOYALTY_POINTS_PAYMENT_TYPE) {
                  // skip adding loyalty payment to payments array as it is already added.
                  continue;
                } else {
                  payments.push(tempPayments[i]);
                }
              }
          } else {
          if (self.cashModel().isPayingByCash()) {
          var payment = {};
          payment.type = ccConstants.CASH_PAYMENT_TYPE;
          if(self.cashModel().customProperties &amp;&amp; (Object.keys(self.cashModel().customProperties).length - 1) > 0) {
            payment.customProperties = ko.mapping.toJS(self.cashModel().customProperties);
          }
          payments.push(payment);
        } else {        
          //Gift Cards
          if (self.giftCards()) {
            for ( var i = 0; i &lt; self.giftCards().length; i++) {
              var payment = {};
              payment.type = ccConstants.GIFT_CARD_PAYMENT_TYPE;
              payment.giftCardNumber = self.giftCards()[i].giftCardNumber();
              payment.giftCardPin = self.giftCards()[i].giftCardPin();
              if (!self.giftCards()[i].isAmountRemaining() || self.isPaypalVerified()) {
                payment.amount = self.giftCards()[i].amountUsed();
              }
              payment.paymentGroupId = self.giftCards()[i].paymentGroupId;
              if(self.giftCards()[i].customProperties &amp;&amp; (Object.keys(self.giftCards()[i].customProperties).length - 1) > 0) {
                payment.customProperties = ko.mapping.toJS(self.giftCards()[i].customProperties);
              }
              payments.push(payment);
            }
          }
        
          if (self.payments().length > 0) {
            // Add any generic payments.
            ko.utils.arrayForEach(self.payments(), function (payment) {
              payments.push(payment);
            });
          } 
          // These entries are for Paypal and credit card respectively. Update here
          // for other payment scenarios.
          else if (self.isPaypalVerified() || (self.amountRemaining &amp;&amp; self.amountRemaining() != 0)) {
            if (self.paymentGateway() &amp;&amp; self.paymentGateway().type) {
              payments.push(self.paymentGateway());
              self.createSpinner();
            } else if(self.isInvoicePayment()) {
              payments.push({type:ccConstants.INVOICE_PAYMENT_TYPE, PONumber:self.poNumber()});
            } else if (self.paymentDetails &amp;&amp; self.paymentDetails() &amp;&amp; self.paymentDetails().isModified()) {
              var payment = {};
              if (!self.isCardPaymentClientSide) {
                payment = new CreditCardPaymentDetails(self.paymentDetails());
                if(self.paymentDetails().customProperties &amp;&amp; (Object.keys(self.paymentDetails().customProperties).length - 1) > 0) {
                payment.customProperties = ko.mapping.toJS(self.paymentDetails().customProperties);
                }
              }
              payment.type = ccConstants.CARD_PAYMENT_TYPE;
              payments.push(payment);
            }
          }
        }
        }	
        }
        
        var op = '';
        if (self.op() != ccConstants.ORDER_OP_INITIATE) {
          op = ccConstants.ORDER_OP_COMPLETE;
        } else {
          op = self.op();
        }
        
        // Clear any previous errors before
        // attempting a new order submission
        notifier.clearError(ORDER_VIEW_MODEL_ID);

        var visitorId = pageViewTracker.getVisitorId();
        var visitId = pageViewTracker.getVisitId();

        // check if OrderViewModel has order id and the user is logged-in to
        // reuse the order to update and submit with changes.
        if (self.user() &amp;&amp; self.user().orderId()
            &amp;&amp; self.user().loggedIn() &amp;&amp; !self.cart().isCartTransient()
            &amp;&amp; !self.hasPaymentType(ccConstants.GENERIC_PAYMENT_TYPE)
            &amp;&amp; ccRestClient.profileType != ccConstants.PROFILE_TYPE_AGENT) {
          var updateOrderData = ko.observable(new Order(self.user().orderId, shoppingCart,
                  appliedPromotions, self.selectedShippingOption(), schedule,
                  shippingAddress, billingAddress, visitorId, visitId,
                  isAnonymousCheckout, null, payments, op, giftWithPurchaseOrderMarkers, shippingGroups, self.cart().combineLineItems));
         
          // Update the order
          self.adapter.persistUpdate('updateOrder', self.user().orderId(),
              self.addDynamicProperties(JSON.parse(ko.toJSON(updateOrderData))),
              // success callback
              function(data) {
                if(self.createOrderSuccessHandler &amp;&amp; $.isFunction(self.createOrderSuccessHandler)) {
                  // Call Split Payments callback success function
                  self.id(data.id);
                  self.order(data);
                  self.orderProfileId(data.orderProfileId);
                  
                  self.createOrderSuccessHandler(data);
                } else {
                  self.postOrderCreateOrUpdateSuccess(data);
                }
              },
              // error callback
              function(data) {
                var param = new Object();
                if (data &amp;&amp; data.errors &amp;&amp; data.errors instanceof Array) {
                  param.orderId = self.id();
                  param.errorCode = "";
                  data.errors.forEach (function(error) {
                    param.errorCode += error.errorCode +", ";
                  });
                  param.errorCode = param.errorCode.slice(0,-2);
                } else {
                  param.orderId = self.id();
                  param.errorCode = data.errorCode;
                };
                self.storeServerLog.logError("updateOrderFailure",self.storeServerLog.getMessage("updateOrderFailure", param));
                self.postOrderCreateOrUpdateFailure(data);
                if(self.createOrderFailureHandler &amp;&amp; $.isFunction(self.createOrderFailureHandler)) {
                	self.createOrderFailureHandler(data);
                } 
              });
        } else {
          if ((!self.paymentGateway() || self.paymentGateway().type != ccConstants.PAYPAL_CHECKOUT_TYPE) &amp;&amp;
                  !self.hasPaymentType(ccConstants.PAYPAL_CHECKOUT_TYPE) &amp;&amp; 
                  !self.hasPaymentType(ccConstants.GENERIC_PAYMENT_TYPE) &amp;&amp; !self.user().loggedIn()) {
               self.id('');
             }
          if (self.cart().currentOrderId()) {
            self.id(self.cart().currentOrderId());
          } else if (self.user() &amp;&amp; self.user().orderId() &amp;&amp; self.user().loggedIn()
                 &amp;&amp; !self.cart().isCartTransient() &amp;&amp; self.hasPaymentType(ccConstants.GENERIC_PAYMENT_TYPE)) {
              // If shopper is logged in and paying with Generic payment, then we should not create a
              // new order, and should submit the profile order
              self.id(self.user().orderId());
          }
          var newOrder = ko.observable(new Order(self.id(), shoppingCart,
              appliedPromotions, self.selectedShippingOption(), schedule,
              shippingAddress, billingAddress, visitorId, visitId,
              isAnonymousCheckout, self.user().id(), payments, op, giftWithPurchaseOrderMarkers, shippingGroups, self.cart().combineLineItems));

          var url;
          if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT){
              newOrder().op = "submitOrder";
              if(self.user().orderId()) {
                newOrder().orderId = self.user().orderId();
              }
          } 
          // Create the order
          var url = ccConstants.ENDPOINT_ORDERS_CREATE_ORDER;
          var requestPayload = self.addDynamicProperties(JSON.parse(ko.toJSON(newOrder)));
          ccRestClient.request(url, requestPayload,
           // success callback
              function(data) {
                if(self.createOrderSuccessHandler &amp;&amp; $.isFunction(self.createOrderSuccessHandler)) {
                  // Call Split Payments callback success function
                  self.id(data.id);
                  self.order(data);
                  data.orderProfileId = data.orderProfileId ? data.orderProfileId : data.profileId
                  self.orderProfileId(data.orderProfileId);
                  
                  self.createOrderSuccessHandler(data);
                } else {
                  data.orderProfileId = data.orderProfileId ? data.orderProfileId : data.profileId
                  self.postOrderCreateOrUpdateSuccess(data);
                }
              },
              // error callback
              function(data) {
                var param = new Object();
                if (data &amp;&amp; data.errors &amp;&amp; data.errors instanceof Array) {
                  param.errorCode = "";
                  data.errors.forEach (function(error) {
                    param.errorCode += error.errorCode +", ";
                  });
                  param.errorCode = param.errorCode.slice(0,-2);
                } else {
                  param.errorCode = data.errorCode;
                };
                self.storeServerLog.logError("createOrderFailure",self.storeServerLog.getMessage("createOrderFailure", param));
                self.postOrderCreateOrUpdateFailure(data);
                if(self.createOrderFailureHandler &amp;&amp; $.isFunction(self.createOrderFailureHandler)) {
                       self.createOrderFailureHandler(data);
                }
              });

        }
      }
      };
      
      /**
       * This adds dynamic properties to the order
       * @private
       * @function
       * @name OrderViewModel#addDynamicProperties
       * @param {Object} orderModel
       * @returns {Object} The updated order model
       */
      OrderViewModel.prototype.addDynamicProperties = function(orderModel) {
        var self = this;
        for ( var i = 0; i &lt; self.cart().dynamicProperties().length; i++) {
          var dynPropItem = self.cart().dynamicProperties()[i];
          var dynPropId = dynPropItem.id();
          var dynPropValue = null;
          if (dynPropItem.value != null) {
            dynPropValue = dynPropItem.value();
          }
          orderModel[dynPropId] = dynPropValue;
        }
        var contextDynamicProperties = storageApi.getInstance().getItem(ccConstants.LOCAL_STORAGE_CURRENT_CONTEXT);
        if(contextDynamicProperties){
          contextDynamicProperties = JSON.parse(contextDynamicProperties);
          for (var key in contextDynamicProperties) {
            if (contextDynamicProperties.hasOwnProperty(key) &amp;&amp; orderModel.hasOwnProperty(key)) {
              orderModel[key] =contextDynamicProperties[key];
            }
          }
        }
        return orderModel;
      };
      
      /**
       * Success callback function for order create or update.
       * @private
       * @function OrderViewModel.postOrderCreateOrUpdateSuccess
       * @param {Object} data Order data.
       */
      OrderViewModel.prototype.postOrderCreateOrUpdateSuccess = function(data) {
        var self = this;
        self.cart().isOrderSubmissionInProgress = false;
        self.id(data.id);
        self.order(data);
        self.orderProfileId(data.orderProfileId);
        self.op('');
        var cartItems;
        /*if(data.__stateData__){
          //If external PLG and Catalog Webhook is used.
          //This happends if webhook returns some other PLG and catalog which doesn't match the PLG and catalog of Order.
          //we will be updating shopper context header in local storage with the value returned from the webhook. 
          storageApi.getInstance().removeItem(ccConstants.LOCAL_STORAGE_SHOPPER_CONTEXT);
          storageApi.getInstance().setItem(ccConstants.LOCAL_STORAGE_SHOPPER_CONTEXT, data.__stateData__);
        }*/
        if (self.user() &amp;&amp; self.user().loggedIn()
            &amp;&amp; self.user().id() == data.orderProfileId) {
          self.user().orderId(data.id);
          self.user().setLocalData('orderId');
        }
        if(data.shoppingCart &amp;&amp; data.shoppingCart.items){
          cartItems = data.shoppingCart.items;
        }
        if (data.state == ccConstants.SUBMITTED || data.stateString == ccConstants.SUBMITTED ) {
          $.Topic(pubsub.topicNames.ORDER_COMPLETED).publish({
            message : "success",
            id : data.id,
            uuid : data.uuid,
            payment : data.payments
          });
          // Redirecting to order confirmation page
          $.Topic(pubsub.topicNames.ORDER_SUBMISSION_SUCCESS).publish([ {
            message : "success",
            id : data.id,
            uuid : data.uuid,
            items : cartItems
          } ]);
        } else {
          if (data.state == ccConstants.TEMPLATE || data.stateString == ccConstants.TEMPLATE) {
            $.Topic(pubsub.topicNames.ORDER_COMPLETED).publish({
              message : "success",
              id : data.id,
              uuid : data.uuid,
              payment : data.payments
            });
            // Redirecting to order confirmation page
            $.Topic(pubsub.topicNames.SCHEDULED_ORDER_SUBMISSION_SUCCESS).publish([ {
              message : "success",
              id : data.id,
              scheduleOrderId: self.restClient.profileType == "agentUI"? data.scheduledOrderId : (data.scheduledOrder.id ? data.scheduledOrder.id :data.scheduledOrder[0].id),
              uuid : data.uuid,
              items : cartItems
            } ]);
          } else if(data.state == ccConstants.PENDING_APPROVAL || data.state == ccConstants.PENDING_SCHEDULED_ORDER_APPROVAL){
            $.Topic(pubsub.topicNames.ORDER_COMPLETED).publish({
              message : "success",
              id : data.id,
              uuid : data.uuid,
              payment : data.payments
            });
            self.destroySpinner();
            // Redirecting to order confirmation page
            $.Topic(pubsub.topicNames.ORDER_SUBMISSION_SUCCESS).publish([ {
              message : "success",
              id : data.id,
              uuid : data.uuid,
              items : cartItems
            } ]);
          }else {
            var paymentGroups = data.payments;
            var isPaymentFailed = false;
            var isProcessed = false;
            var isPayPalGeneric = false;
            for ( var i = 0; i &lt; paymentGroups.length; i++) {
              if (paymentGroups[i].paymentState == ccConstants.PAYMENT_GROUP_STATE_AUTHORIZED_FAILED || 
                  paymentGroups[i].paymentState == ccConstants.PAYMENT_GROUP_STATE_PAYMENT_REQUEST_FAILED) {
                this.destroySpinner();
                isProcessed =  true;
                // clear the order if the authorization fails for anonymous user,
                // so that it should create the order.
                var orderError = "";
                if (paymentGroups[i] &amp;&amp; paymentGroups[i].message
                    &amp;&amp; paymentGroups[i].message !== '') {
                  orderError = paymentGroups[i].message;
                  var param = {
                           orderId        : data.id,
                           paymentState   : paymentGroups[i].paymentState,
                           paymentGroupId : paymentGroups[i].paymentGroupId
                  };
                  self.storeServerLog.logError("paymentGroupFailure",self.storeServerLog.getMessage("paymentGroupFailure", param));
                } else {
                  var param = {
                           orderId : data.id,
                  };
                  self.storeServerLog.logError("orderSubmissionFailure",self.storeServerLog.getMessage("orderSubmissionFailure", param));
                  orderError = CCi18n.t('ns.common:resources.orderSubmissionFailed');
                }
                notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
                $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).publishWith(data, [ {
                    message : "fail",
                    data : paymentGroups[i]
                } ]);
                isPaymentFailed = true;
                if (self.isPaypalVerified() || self.cart().checkoutWithPaypalClicked()) {
                  self.clearPaypalData();
                }
                break;
              }
            }

            //if any payment failed then do not process other payments
            if (!isPaymentFailed) {
             for (var i=0 ; i&lt;paymentGroups.length ; i++){
                if (paymentGroups[i].type == ccConstants.PAYPAL_PAYMENT_TYPE
                    &amp;&amp; paymentGroups[i].uiIntervention == ccConstants.REDIRECT) {
                  isProcessed =  true;
                  // After being redirected to web payment page if a shopper clicks the 'back' button
                  // then in Safari, the page is not refreshed. This leads to all view models holding stale
                  // data. Thus, currently paymentGateway data needs to be reset.
                  self.paymentGateway(null);
                  //set a flag in local storage to indicate that the page is redirected to a web url. 
                  //so, when coming back to store page, as all the view models are reset, use this flag to determine
                  // whether the page was redirected to a web payment page.
                  storageApi.getInstance().setItem(ccConstants.REDIRECTED_TO_WEB_PAYMENT, 'true');
                  window.location = data.payments[i].REDIRECT;
                  break;
                } else if (paymentGroups[i].type === ccConstants.PAYPAL_PAYMENT_TYPE ||
                           paymentGroups[i].type === ccConstants.GENERIC_PAYMENT_TYPE) {
                  isPayPalGeneric = true;
                  isProcessed =  true;
                  break;
                } else if (paymentGroups[i].type == ccConstants.CYBERSOURCE_GATEWAY
                    &amp;&amp; paymentGroups[i].uiIntervention == ccConstants.SOP) {
                  isProcessed =  true;
                  // Redirecting to the payment page.
                  this.destroySpinner();
                  navigation.goTo(self.paymentLink, true);
                  $.Topic(pubsub.topicNames.ORDER_CREATED).publish([{
                    message: "success",
                    id: data.id,
                    uuid: data.uuid
                  }]);
                  break;
                } else if(paymentGroups[i].uiIntervention == ccConstants.PAYER_AUTH_REQUIRED){
                  isProcessed =  true;
                  this.destroySpinner();
                  navigation.goTo(self.paymentLink, true);
                  $.Topic(pubsub.topicNames.ORDER_CREATED).publish([{
                    message: "success",
                    id: data.id,
                    uuid: data.uuid,
                    customPaymentProperties:paymentGroups[i].customPaymentProperties
                  }]);
                  break;
                } else if (paymentGroups[i].type &amp;&amp; paymentGroups[i].type == ccConstants.PAYULATAM_CHECKOUT_TYPE
                        &amp;&amp; paymentGroups[i].uiIntervention == ccConstants.SOP) {
                  isProcessed =  true;
                  $.Topic(pubsub.topicNames.PAYULATAM_WEB_CHECKOUT).publishWith(
                      paymentGroups[i],
                      [{message: "success", id: data.id, uuid: data.uuid}]
                  );
                  storageApi.getInstance().setItem(ccConstants.REDIRECTED_TO_WEB_PAYMENT, 'true');
                  break;
                }
              }
            }

            //this should not happen at all
            if (!isProcessed) {
              this.destroySpinner();
              var orderError = CCi18n.t('ns.common:resources.orderSubmissionFailed');
              notifier.sendError(ORDER_VIEW_MODEL_ID, orderError, true);
              $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).publishWith(data, [ {
                  message : "fail",
                  data : data
              } ]);
            } else {
              if (data.state === ccConstants.INCOMPLETE || isPayPalGeneric) {
                // Send an event that the initial Order was created.
                $.Topic(pubsub.topicNames.ORDER_CREATED_INITIAL).publishWith(data, [{
                    message : "success",
                    order : data
                  }]);
              }
              this.destroySpinner();
            }
          }
        }
      };

      /**
       * Error callback function for order create or update.
       * @private
       * @function OrderViewModel.postOrderCreateOrUpdateFailure
       * @param {Object} data Callback data.
       */
      OrderViewModel.prototype.postOrderCreateOrUpdateFailure = function(data) {
        var self = this;
        this.destroySpinner();
        self.cart().isOrderSubmissionInProgress = false;
        if (data &amp;&amp; data.message &amp;&amp; data.message !== '') {
          if(data.__stateData__){
            //This error will be throw only if external PLG and Catalog Webhook is used.
            //this happends if webhook returns some other PLG and catalog which doesn't match the PLG and catalog of Order.
            //we will be updating shopper context header in local storage with the value returned from the webhook. 
            storageApi.getInstance().removeItem(ccConstants.LOCAL_STORAGE_SHOPPER_CONTEXT);
            storageApi.getInstance().setItem(ccConstants.LOCAL_STORAGE_SHOPPER_CONTEXT, data.__stateData__);
          }
          if (data.errorCode == ccConstants.INVENTORY_CONFIGURABLE_ITEM_CHECK_ERROR) {
            data.message = CCi18n.t('ns.common:resources.orderPricingPromotionError');
            notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
          }else if (data.errors instanceof Array) {
            var errorCaught = false;
            for (var i in data.errors) {
              if (data.errors[i].errorCode == ccConstants.EXTERNAL_PRICE_CHANGED ||
                data.errors[i].errorCode == ccConstants.EXTERNAL_PRICE_PARTIAL_FAILURE_ERROR) {
                data.message = CCi18n.t('ns.common:resources.orderPricingPromotionError');
                notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
                errorCaught = true;
                break;
              }
              else{
								errorCaught = self.checkSingleException(data);
								if (errorCaught == true)
									break;
							}
            }
          }
          else{
						self.checkSingleException(data);
          }
        }
        $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).publishWith(data, [ {
          message : "fail",
          data : data
        } ]);
      };

      /**
       * Order Created. Auth Payment.
       * @private
       * @function OrderViewModel.authPayment
       */
      OrderViewModel.prototype.authPayment = function() {
        var self = this;
        var order = self.order();
        var paymentAuthDetails = new PaymentAuthDetails(self.emailAddress(), ko
            .toJS(self.billingAddress()), self.paymentDetails(), self.order());

        $.Topic(pubsub.topicNames.ORDER_AUTHORIZE_PAYMENT).publish([ {
          message : "success",
          details : paymentAuthDetails
        } ]);

      };

      /**
       * Payment Authorized. Submit the order.
       * @private 
       * @function OrderViewModel.paymentAuthorized
       * @param {Object} data Payment data.
       */
      OrderViewModel.prototype.paymentAuthorized = function(data) {
        
        // Confirmation page to be displayed based on order state SUBMITTED, and should not
        // be based on the PaymentGroup authorization (after split payments)
        if(data[0].orderState != ccConstants.SUBMITTED) {
          return;
        }
        $.Topic(pubsub.topicNames.ORDER_SUBMISSION_SUCCESS).publish([ {
          message : "success",
          id : data[0].id,
          uuid : data[0].uuid,
          items : ko.mapping.toJS(this.cart().items())
        } ]);
      };

      /**
       * Payment Declined. Order submission failed.
       * &lt;p>
       * Publishes an ORDER_SUBMISSION_FAIL message.
       * @private
       * @function OrderViewModel.paymentDeclined
       * @param {Object} data (unused)
       */
      OrderViewModel.prototype.paymentDeclined = function(data) {

        $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).publish([ {
          message : "fail"
        } ]);

      };

      /**
       * Payment auth timed out. Order submission failed.
       * &lt;p>
       * Publishes an ORDER_SUBMISSION_FAIL message.
       * @private
       * @function OrderViewModel.paymentTimeout
       * @param {Object} data (unused)
       */
      OrderViewModel.prototype.paymentTimeout = function(data) {

        $.Topic(pubsub.topicNames.ORDER_SUBMISSION_FAIL).publish([ {
          message : "fail"
        } ]);

      };

      /**
       * Set context data.
       * @function OrderViewModel.setContext
       * @param {Object} pContext Context data.
       */
      OrderViewModel.prototype.setContext = function(pContext) {
        this.contextData = pContext;
        this.paymentLink = this.contextData.global.links.payment.route;
        this.checkoutLink = this.contextData.global.links.checkout.route;
        this.cartLink = this.contextData.global.links.cart.route;
        if(ccRestClient.profileType == ccConstants.PROFILE_TYPE_AGENT) {
          this.agentCheckoutLink = this.contextData.global.links.agentCheckout.route;
        }
        this.isCardPaymentClientSide = this.contextData.page.payment.isCardPaymentClientSide;
        if(this.contextData &amp;&amp; this.contextData.global &amp;&amp; this.contextData.global.site 
            &amp;&amp; this.contextData.global.site.extensionSiteSettings 
            &amp;&amp; this.contextData.global.site.extensionSiteSettings.storeEndpointSettings 
            &amp;&amp; this.contextData.global.site.extensionSiteSettings.storeEndpointSettings.cartFields)
        this.fields = this.contextData.global.site.extensionSiteSettings.storeEndpointSettings.cartFields;
      };

      /**
       * Destroy the 'loading' spinner.
       * @function  OrderViewModel.destroySpinner
       */
      OrderViewModel.prototype.destroySpinner = function() {
        $('#loadingModal').hide();
        spinner.destroy();
      };

      /**
       * Create the 'loading' spinner.
       * @function  OrderViewModel.createSpinner
       */
      OrderViewModel.prototype.createSpinner = function(loadingText) {
        var indicatorOptions = {
          parent : '#loadingModal',
          posTop : '0',
          posLeft : '50%'
        };
        var loadingText = CCi18n.t('ns.common:resources.loadingText');
        $('#loadingModal').removeClass('hide');
        $('#loadingModal').show();
        indicatorOptions.loadingText = loadingText;
        spinner.create(indicatorOptions);
      };
      
      /**
       * Add an Order Calidation Callback. Will be invoked by handlePlaceOrder.
       * @function OrderViewModel.addValidationCallback
       * @param {Object} pCallbackFunction the callback function
       */
      OrderViewModel.prototype.addValidationCallback = function(pCallbackFunction) {
        if (pCallbackFunction &amp;&amp; typeof(pCallbackFunction) === "function") {
          this.validationCallbacks.push(pCallbackFunction);
        }
      };
      
      /**
       * Trigger any Order Validation Callbacks currently registered.
       * @function OrderViewModel.triggerValidationCallbacks
       */
      OrderViewModel.prototype.triggerValidationCallbacks = function() {
        if (this.validationCallbacks.length > 0) {
          var length = this.validationCallbacks.length;
          for (var i = 0; i &lt; length; i++) {
            if (this.validationCallbacks[i] &amp;&amp; 
                typeof(this.validationCallbacks[i]) === "function") {
              this.validationCallbacks[i]();
            }
          }
        }
      };
      
      /**
       * Add an Order Validation Error.
       * @function OrderViewModel.addValidationError
       * @param {String} pMessageId the message ID. Can be used to clear message later.
       * @param {String} pMessage the message. If not set, default message used.
       */
      OrderViewModel.prototype.addValidationError = function(pMessageId, pMessage) {
        this.errorFlag = true;
        var message = pMessage;
        if (!message || message === '') {
          message = CCi18n.t('ns.common:resources.checkoutErrorMsg');
        }
        notifier.sendError(pMessageId, message, true);
      };
      
      OrderViewModel.prototype.postPaymentOrderUpdateSuccess = function(paymentData) {
          var self = this;
          var oId=paymentData.orderId;
          //Get Order with orderId
          var url=ccConstants.ENDPOINT_GET_ORDER;
          for(var i=0; i &lt; paymentData.paymentResponses.length ; i++){
        	  if(paymentData.paymentResponses[i].type == ccConstants.PAYPAL_PAYMENT_TYPE){
        		  storageApi.getInstance().setItem(ccConstants.PAYMENT_GROUP_AFTER_PAYPAL, paymentData.paymentResponses[i].paymentGroupId);
        	  }
          }
          ccRestClient.request(url, null,
                  // success callback
                  function(data) {
        	  for(var i=0; i &lt; paymentData.paymentResponses.length ; i++){
        		  for(var j=0; j &lt; data.payments.length ; j++){
        			  if(paymentData.paymentResponses[i].paymentGroupId == data.payments[j].paymentGroupId){
        				  data.payments[j].customPaymentProperties = paymentData.paymentResponses[i].customPaymentProperties;
        				  data.payments[j].uiIntervention = paymentData.paymentResponses[i].uiIntervention;
        				  break;
                	  }
        		  }
        	  }
        	  
        	  self.postOrderCreateOrUpdateSuccess(data);
          	  },
            // error callback
           function(data) {
        	  self.destroySpinner();
        	  notifier.sendError(ORDER_VIEW_MODEL_ID, data.message, true);
          	  },oId);
        };
      

      /**
       * Represents an order object.
       * 
       * @private
       * @class Order
       * @memberof OrderViewModel
       * @param {integer} pOrder ID The order ID.
       * @param {ShoppingCart} pShoppingCart The shopping cart.
       * @param {string[]} pAppliedPromotions The list of applied promotions.
       * @param {string} pSelectedShippping Selected shipping method.
       * @param {Address} pShippingAddress The shipping address.
       * @param {string} pVisitorId The visitor ID.
       * @param {string} pVisitId The visit ID.
       * @param {boolean} pIsAnonymousCheckout Anonymous checkout?
       * @param {string} pProfileId The profile ID
       * @param {PaypalPaymentDetails} pPayment The payment details object.
       * @param {string} pOp The operation
       * 
       * @property {integer} id The order ID.
       * @property {ShoppingCart} shoppingCart The shopping cart.
       * @property {string[]} appliedPromotions The list of applied promotions.
       * @property {boolean} isAnonymousCheckout Anonymous checkout?
       * @property {string} shippingMethod The shipping method.
       * @property {Address} shippingAddress The shipping address.
       * @property {PaypalPaymentDetails} payment The payment details object.
       * @property {string} visitorId The visitor ID.
       * @property {string} visitId The visit ID.
       * @property {string} profileId The profile ID, set when not checking out anonymously.
       * @property {string} op The operation
       * @property {array} giftWithPurchaseOrderMarkers The order marker information
       * @property {array} shippingGroups The shipping groups
       * @property {boolean} combineLineItems yes if line items are to be combined.        
       */
      function Order(pOrderId, pShoppingCart, pAppliedPromotions,
          pSelectedShippping, pSchedule, pShippingAddress, pBillingAddress, pVisitorId,
          pVisitId, pIsAnonymousCheckout, pProfileId, pPayments, pOp, 
          pGiftWithPurchaseOrderMarkers, pShippingGroups, pCombineLineItems) {
        var self = this;

        if (pOrderId) {
          self.id = pOrderId;
        }

        self.shoppingCart = pShoppingCart;
        self.appliedPromotions = pAppliedPromotions;
        self.isAnonymousCheckout = pIsAnonymousCheckout;
        self.combineLineItems = pCombineLineItems;

        //Add Schedule information to order if not present
        if (pSchedule) {
          self.scheduleOnly = true;
          self.schedule = pSchedule;
        }

        // Are there multiple shipping addresses for this order.
        if (pShippingGroups) {
          // Yes - Populate the shipping groups structure.
          self.shippingGroups = pShippingGroups;
        }
        else{
          // No - Set single shipping address and shipping method.
          if (pShippingAddress) {
            self.shippingAddress = pShippingAddress;
          }
          if (pSelectedShippping) {
            // Sending only the shipping method id for the create/update order endpoint input
            self.shippingMethod = {"value" : pSelectedShippping.value};
          }
        }
        if (pBillingAddress) {
          self.billingAddress = pBillingAddress;
        }
        if (pPayments) {
          self.payments = pPayments;
        }
        self.visitorId = pVisitorId;
        self.visitId = pVisitId;
        if (!pIsAnonymousCheckout) {
          self.profileId = pProfileId;
        }
        self.op = pOp;
        self.giftWithPurchaseOrderMarkers = pGiftWithPurchaseOrderMarkers;
      }

      /**
       * OrderItem is a data copy of a CartItem instance, used in the create/update order payload.
       * 
       * @private
       * @class OrderItem
       * @memberof OrderViewModel
       * @param {CartItem} cartItem The original cart item instance, from which the order item instance is copied.
       * @property {string} productId The product ID.
       * @property {integer} quantity The quantity.
       * @property {string} catRefId The catalog reference ID.
       * @property {Array} giftWithPurchaseCommerceItemMarkers The commerce item marker information.
       * @property {Array} externalData The dynamic externalData for this order item.
       * @property {string} actionCode The action code for this order item.
       * @property {number} externalRecurringCharge The item's rucurring price as supplied from an external 
       *    system, i.e. not the commerce catalog.
       * @property {string} externalRecurringChargeFrequency The frequency, e.g. "Weekly", "Monthly", associated with 
       *    the item's external recurring price.
       * @property {string} externalRecurringChargeDuration The duration, e.g. "1 Year", associated with the 
       *    item's external recurring price. This is for display only and is not used in calculations.
       * @property {string} assetKey The asset that is associated to the commerce item of an ABO (Asset Based Order).
       *    Services and assets are essentially different names for the same thing. This is property is set by the 
       *    external configurator system, to be used by external downstream system such as fullfillment and billing.
       * @property {string} rootAssetKey The root asset that is associated to the commerce item of an ABO (Asset Based Order).
       *    Services and assets are essentially different names for the same thing. This is property is set by the
       *    external configurator system, to be used by external downstream system such as fullfillment and billing.
       * @property {string} parentAssetKey The parent asset that is associated to the commerce item of an ABO (Asset Based Order).
       *    Services and assets are essentially different names for the same thing. This is property is set by the
       *    external configurator system, to be used by external downstream system such as fullfillment and billing.
       * @property {string} serviceId The service that is associated to the commerce item of an ABO (Asset Based Order). 
       *    Services and assets are essentially different names for the same thing. This is property is set by the 
       *    external configurator system, to be used by external downstream system such as fullfillment and billing.
       * @property {string} customerAccountId The account that is associated to the commerce item of an ABO 
       *    (Asset Based Order). This is property is set by the external configurator system, to be used by external 
       *    downstream system such as fullfillment and billing.
       * @property {string} billingAccountId The billing account that is associated to the commerce item of an ABO 
       *    (Asset Based Order). This is property is set by the external configurator system, to be used by external 
       *    downstream system such as fullfillment and billing.
       * @property {string} serviceAccountId The service account that is associated to the commerce item of an ABO
       *    (Asset Based Order). This is property is set by the external configurator system, to be used by external 
       *    downstream system such as fullfillment and billing.
       * @property {string} billingProfileId The billing profile that is associated to the commerce item of an ABO
       *    (Asset Based Order). This is property is set by the external configurator system, to be used by external
       *    downstream system such as fullfillment and billing.
       * @property {string} activationDate The activation date that is associated to the commerce item of an ABO 
       *    (Asset Based Order). This is property is set by the external configurator system, to be used by external 
       *    downstream system such as fullfillment and billing.
       * @property {string} deactivationDate The deactivation date that is associated to the commerce item of an ABO 
       *    (Asset Based Order). This is property is set by the external configurator system, to be used by external 
       *    downstream system such as fullfillment and billing.
       * @property {string} transactionDate The transaction date that is associated to the commerce item of an ABO 
       *    (Asset Based Order). This is property is selected by the user (or defaulted by client application), 
       *    to be used by external downstream system such as fullfillment and billing.
       * @property {boolean} asset The When a configurable item is also an asset, this flag will be set to true.
       * @property {Object} shopperInput The Shopper Inputs for this order item.
       */
      function OrderItem(cartItem) {
        $.extend(this, {
          productId: cartItem.productId,
          quantity: cartItem.quantity,
          catRefId: cartItem.productData().childSKUs[0].repositoryId,
          externalPrice: cartItem.externalPrice,
          externalPriceQuantity: cartItem.externalPriceQuantity,
          giftWithPurchaseCommerceItemMarkers: cartItem.giftWithPurchaseCommerceItemMarkers,
          externalData: cartItem.externalData,
          actionCode: cartItem.actionCode,
          commerceItemId: cartItem.commerceItemId,
          externalRecurringCharge: cartItem.externalRecurringCharge,
          externalRecurringChargeFrequency: cartItem.externalRecurringChargeFrequency,
          externalRecurringChargeDuration: cartItem.externalRecurringChargeDuration,
          assetKey: cartItem.assetKey,
          rootAssetKey: cartItem.rootAssetKey,
          parentAssetKey: cartItem.parentAssetKey,
          serviceId: cartItem.serviceId,
          customerAccountId: cartItem.customerAccountId,
          billingAccountId: cartItem.billingAccountId,
          serviceAccountId: cartItem.serviceAccountId,
          billingProfileId: cartItem.billingProfileId,
          activationDate: cartItem.activationDate,
          deactivationDate: cartItem.deactivationDate,
          transactionDate: cartItem.transactionDate,
          asset: cartItem.asset,
          shopperInput: cartItem.shopperInput
        });
      }

      /**
       * Represents a shopping cart.
       * @private
       * @class ShoppingCart
       * @memberof OrderViewModel
       * @param {OrderItem[]} pItems The items in the cart.
       * @param {string[]} pCoupons List of coupons.
       * @param {float} pOrderTotal Order total.
       * @property {OrderItem[]} items The items in the cart.
       * @property {string[]} coupons List of coupons.
       * @property {float} orderTotal Order total.
       */
      function ShoppingCart(pItems, pCoupons, pOrderTotal) {
        var self = this;
        self.items = pItems;
        self.coupons = pCoupons;
        self.orderTotal = pOrderTotal;
      }

      /**
       * Payment authorisation details.
       * @private
       * @class PaymentAuthDetails
       * @memberof OrderViewModel
       * @param {string} pEmailAddress Email address.
       * @param {Address} pBillingAddress Billing address.
       * @param {Object} pPaymentDetails The payment details.
       * @param {Object} pOrderDetails The order details.
       * @property {string} emailAddress Email address.
       * @property {Address} billingAddress Billing address.
       * @property {Object} paymentDetails The payment details.
       * @property {Object} orderDetails The order details.
       */
      function PaymentAuthDetails(pEmailAddress, pBillingAddress,
          pPaymentDetails, pOrderDetails) {
        var self = this;
        self.emailAddress = pEmailAddress;
        self.billingAddress = pBillingAddress;
        self.paymentDetails = pPaymentDetails;
        self.orderDetails = pOrderDetails;
      }

      /**
       * Credit Card Payment Details.
       * @private
       * @class CreditCardPaymentDetails
       * @memberof OrderViewModel
       * @param {Object} pPaymentDetails Payment Details.
       * @property {string} nameOnCard The name on card.
       * @property {Address} billingAddress Billing address.
       * @property {Object} paymentDetails The payment details.
       * @property {Object} orderDetails The order details.
       */
      function CreditCardPaymentDetails(pPaymentDetails) {
        var self = this;
        self.nameOnCard = pPaymentDetails.nameOnCard();
        //self.cardType = pPaymentDetails.cardType();
        if (pPaymentDetails.selectedCardType() == null) {
          self.cardType = pPaymentDetails.cardType();
        } else {
          self.cardType = pPaymentDetails.selectedCardType();
        }
        self.cardNumber = pPaymentDetails.cardNumber(); 
        self.cardCVV = pPaymentDetails.cardCVV();
        self.endMonth = pPaymentDetails.endMonth();
        self.endYear = pPaymentDetails.endYear();
        if (pPaymentDetails.selectedCardType() == null) {
          self.selectedCardType = pPaymentDetails.cardType();
        } else {
          self.selectedCardType = pPaymentDetails.selectedCardType();
        }
        if (pPaymentDetails.selectedEndMonth() == null) {
          self.selectedEndMonth = pPaymentDetails.endMonth();
        } else {
          self.selectedEndMonth = pPaymentDetails.selectedEndMonth();
        }
        if (pPaymentDetails.selectedEndYear() == null) {
          self.selectedEndYear = pPaymentDetails.endYear();
        } else {
          self.selectedEndYear = pPaymentDetails.selectedEndYear();
        }
      }
      
      /**
       * Credit Card Payment Details.
       * @private
       * @class CreditCardPaymentDetails
       * @memberof OrderViewModel
       * @param {Object} pPaymentDetails Payment Details.
       * @property {string} nameOnCard The name on card.
       * @property {Address} billingAddress Billing address.
       * @property {Object} paymentDetails The payment details.
       * @property {Object} orderDetails The order details.
       */
      function CreditCardPaymentDetailsClientSide(pPaymentDetails) {
        var self = this;
        self.nameOnCard = pPaymentDetails.nameOnCard();
        //self.cardType = pPaymentDetails.cardType();
        if (pPaymentDetails.selectedCardType() == null) {
          self.cardType = pPaymentDetails.cardType();
        } else {
          self.cardType = pPaymentDetails.selectedCardType();
        }
        self.cardNumber = pPaymentDetails.cardNumber(); 
        self.cardCVV = pPaymentDetails.cardCVV();
        self.expiryMonth = pPaymentDetails.endMonth();
        self.expiryYear = pPaymentDetails.endYear().toString();
        if (pPaymentDetails.selectedCardType() == null) {
          self.selectedCardType = pPaymentDetails.cardType();
        } else {
          self.selectedCardType = pPaymentDetails.selectedCardType();
        }
        if (pPaymentDetails.selectedEndMonth() == null) {
          self.selectedEndMonth = pPaymentDetails.endMonth();
        } else {
          self.selectedEndMonth = pPaymentDetails.selectedEndMonth();
        }
        if (pPaymentDetails.selectedEndYear() == null) {
          self.selectedEndYear = pPaymentDetails.endYear();
        } else {
          self.selectedEndYear = pPaymentDetails.selectedEndYear();
        }
      }
      /**
       * PayPal Payment details.
       * @private
       * @class PaypalPaymentDetails
       * @memberof OrderViewModel
       * @param {string} pPaymentType Payment type.
       * @param {string} pPaymentId Payment ID.
       * @param {string} pToken The payment token.
       * @param {string} pPayerID The payer ID.
       * @property {string} type Payment type.
       * @property {string} paymentId Payment ID.
       * @property {string} token The payment token.
       * @property {string} PayerID The payer ID.
       */
      function PaypalPaymentDetails(pPaymentType, pPaymentId, pToken, pPayerID, pPaymentGroupId) {
        var self = this;
        self.type = pPaymentType;
        self[ccConstants.PAYMENT_ID] = pPaymentId;
        self[ccConstants.TOKEN] = pToken;
        self[ccConstants.PAYER_ID] = pPayerID;
        self[ccConstants.PAYMENT_GROUP_ID] = pPaymentGroupId;
      }
      
      /**
       * PayULatam Payment details.
       * @private
       * @class PayULatamPaymentDetails
       * @memberof OrderViewModel
       * @param {string} pPaymentType Payment type.
       * @param {string} pAmount amount.
       * @param {string} pCurrency Currency Code.
       * @param {string} pPaymentId ReferenceCode of the payment.
       * @param {string} pTransactionStatus Transaction Status in PayU System.
       * @param {string} pTransactionType TransactionType such as initial, response, etc. 
       * @param {string} pSignature Signature received in PayU response.
       * @property {string} type Payment type.
       * @property {string} amount Amount.
       * @property {string} currency Currency Code.
       * @property {string} paymentId ReferenceCode of the payment.
       * @property {string} transactionStatus Transaction Status in PayU System.
       * @property {string} transactionType TransactionType such as initial, response, etc.
       * @property {string} Signature received in PayU response.
       */
      function PayULatamPaymentDetails(pPaymentType, pAmount, pCurrency, 
          pPaymentId, pTransactionStatus, pTransactionType, pSignature) {
        var self = this;
        self.type = pPaymentType;
        self[ccConstants.AMOUNT] = pAmount;
        self[ccConstants.CURRENCY] = pCurrency;
        self[ccConstants.PAYMENT_ID] = pPaymentId;
        self[ccConstants.TRANSACTION_STATUS] = pTransactionStatus;
        self[ccConstants.TRANSACTION_TYPE] = pTransactionType;
        self[ccConstants.SIGNATURE] = pSignature;
      }
      
      function ExceptionMessage(pError, pShoppingCartItems, pEmailId, pVisitorId, pVisitId) {
          var errMessage = {};
          errMessage.msg = pError.toString();
          errMessage.shoppingCartItems = pShoppingCartItems;
          errMessage.emailId = pEmailId;
          errMessage.visitorId = pVisitorId;
          errMessage.visitId = pVisitId;
          
          errMessage.toJSON = function() {
              var copy = ko.toJS(errMessage);
              return copy;
            };
            return errMessage;
      }
      
   // Click handler for the place order button when order is in PENDING_PAYMENT state.   
      OrderViewModel.prototype.handlePayments = function() {
        	try {
              //clear error notifications if present
              notifier.clearError("handlePlaceOrder");
              this.enableOrderButton(false);
              this.errorFlag = false;
              this.isOrderSubmitted = false;
              if(this.shippingAddressAsBilling()){
                this.shippingAddress().copyTo(this.billingAddress());
              }
              // If its somehow possible that a second click got through
              // before the button was disabled, then stop it here
              if (!this.isOrderLocked &amp;&amp; !this.isOrderSubmitted) {
                this.isOrderLocked = true;
                           
                this.triggerValidationCallbacks();

                if (!(this.isPayLater())) {
                  this.invokePaymentValidations();
                }
             
                //validating billingAddress
                this.validateBillingAddress();

                //validating dynamic properties
                this.validateDynamicProperties();

                // Any invalid data will have caused the error flag to be set
                if (!this.errorFlag) {
                  this.createSpinner();
                  // Check if the payment is a payU type checkout
                  if (this.isPayULatamCheckout()) {
                    this.preparePayULatamDataForCreateOrder(ccConstants.PAYULATAM_CHECKOUT_TYPE);
                  }
                  // All good. proceed with order.
                  if (this.user().loggedIn() &amp;&amp; !this.user().isB2BUser()) {
                    this.placeOrder = true;
                    this.user().handleUpdateProfile();
                  } else {
                  	if(this.isSplitPayment()) {
                  		this.invokePaymentsAPIHandler();
                  	} else {
                  		this.addPaymentsToOrder();
                  	}
                  }
                } else {
                  // Enable button again
                  this.enableOrderButton(true);
                  notifier.sendError("handlePlaceOrder", CCi18n.t('ns.common:resources.checkoutErrorMsg'), true);
                }
                this.isOrderLocked = false;
              }
        	} catch (e) {
              // Enable button again
              this.enableOrderButton(true);
              this.isOrderLocked = false;
              var emailAddr = this.user().loggedIn() ? this.user().emailAddress() : this.emailAddress();
              var msg = new ExceptionMessage(e, this.cart().items(), emailAddr, pageViewTracker.getVisitorId(), pageViewTracker.getVisitId());
              this.exceptionHandler.logWindowOnError(JSON.stringify(msg),'','');
        	}
          };
      
          
      OrderViewModel.prototype.disablePaymentIfNecessary = function(){
    	  var self =this;
          if(self.cart().items().length > 0 &amp;&amp; self.isPaymentsDisabled()){
            self.isPaymentDisabled(true);
          }else{
        	self.isPaymentDisabled(false); 
          }
      }    
      // Click handler for the place order button
      OrderViewModel.prototype.handlePlaceOrder = function() {
    	try {
          //clear error notifications if present
          notifier.clearError("handlePlaceOrder");
          this.enableOrderButton(false);
          this.errorFlag = false;
          this.isOrderSubmitted = false;
          this.isShippingAddressModified = this.shippingAddress().isModified();
          this.isBillingAddressModified = this.billingAddress().isModified();
          if(this.shippingAddressAsBilling()){
            this.shippingAddress().copyTo(this.billingAddress());
          }
          // If its somehow possible that a second click got through
          // before the button was disabled, then stop it here
          if (!this.isOrderLocked &amp;&amp; !this.isOrderSubmitted) {
            this.isOrderLocked = true;

            //validating checkoutRegistration 
            this.validateCheckoutRegistration();

            //validating checkout-cart-summary 
            this.validateCheckoutCartSummary();

          //validating schedule order information
          if (this.showSchedule()) {
            this.validateSchedule();
          }
            // if split shipping
            if (this.cart().isSplitShipping()) { 
              this.validateShippingGroupRelationships();
            }
            else {
              // validating shippingAddress
              this.validateShippingAddress();


              //validating checkout-order-summary
              this.validateCheckoutOrderSummary();
            }
          
            this.triggerValidationCallbacks();
            if (!(this.isPayLater())) {
              this.invokePaymentValidations();
            }
            //validating billingAddress
            this.validateBillingAddress();

            //validating dynamic properties
            this.validateDynamicProperties();

            // check if any placeholder items exist in the cart
            if (!this.placeHolderItemsMsgDisplayed) {
              this.validatePlaceHolderItems();
            }

            // Any invalid data will have caused the error flag to be set
            if (!this.errorFlag) {
                $.Topic(pubsub.topicNames.CHECKOUT_SAVE_SHIPPING_ADDRESS).
                  publishWith(this.shippingAddress(), [{message: "success", shippingGroups: this.cart().orderShippingGroups()}]);
              this.createSpinner();
              // Check if the payment is a payU type checkout
              if (this.isPayULatamCheckout()) {
                this.preparePayULatamDataForCreateOrder(ccConstants.PAYULATAM_CHECKOUT_TYPE);
              }
              // All good. proceed with order.
              if (!this.user().contextData.global.enableProfileRegistrationEmailCheck &amp;&amp; this.createAccount() === true) {
                // Publish the pubsub to login
                var obj = {widgetId: "checkoutRegistration"};
                this.user().updateLocalData(true, false);
                this.user().registerUser(obj);
                this.registerUser = true;
              } else if (this.user().contextData.global.enableProfileRegistrationEmailCheck &amp;&amp; this.createAccount() === true) {
				notifier.sendWarning(ORDER_VIEW_MODEL_ID, CCi18n.t('ns.common:resources.placeOrderRegisterWarnMsg'), true);
			  } else if (this.user().loggedIn() &amp;&amp; !this.user().isB2BUser()) {
                this.placeOrder = true;
                this.user().handleUpdateProfile();
              } else {
                this.createOrder();
              }
            } else {
              // Enable button again
              this.enableOrderButton(true);
              }
            this.isOrderLocked = false;
          }
    	} catch (e) {
          // Enable button again
          this.enableOrderButton(true);
          this.isOrderLocked = false;
          var emailAddr = this.user().loggedIn() ? this.user().emailAddress() : this.emailAddress();
          var msg = new ExceptionMessage(e, this.cart().items(), emailAddr, pageViewTracker.getVisitorId(), pageViewTracker.getVisitId());
          this.exceptionHandler.logWindowOnError(JSON.stringify(msg), '', '', '', e);
          this.cart().isOrderSubmissionInProgress = false;
    	}
      };

      /**
       * Function to verify if order requires approval.
       * @private
       * @function OrderViewModel.checkOrderForApproval
       * @param {Object} data {orderId}
       */
      OrderViewModel.prototype.checkOrderForApproval = function(data) {
        var self = this;
        var inputData = {};
        inputData["orderId"] = data.orderId;
        var url = "checkRequiresApproval";
        ccRestClient.request(url, inputData, function(pData){
          self.approvalRequired(pData.requiresApproval);
        },function(pError){ 
          //TODO: Handle if error occurs
        });
      };
      /*
       * Method to handle page ready event.
       * 
       * @function OrderViewModel#handlePageReady
       * @param {string} pData data published on page ready topic.
       */
      OrderViewModel.prototype.handlePageReady = function(pData) {
        var self = this;
        self.loadOrderForSubmit(pData);
      };

      /**
       * Returns a single global instance of OrderViewModel.
       * Creates the instance if it does not already exist.
       * 
       * @function OrderViewModel.getInstance
       * @param {Object} pAdapter The rest adapter.
       * @param {CartViewModel} pCart The cart.
       * @param {Object} pData Additional data.
       * @returns {OrderViewModel} The single global instance.
       */
      OrderViewModel.getInstance = function(pAdapter, pCart, pData, params, pUser) {
        if (!OrderViewModel.prototype.singleInstance) {
          OrderViewModel.prototype.singleInstance = new OrderViewModel(
              pAdapter, pCart, pData, pUser);
        }

        if (params) {
          OrderViewModel.prototype.singleInstance.setContext(params);
        }
        return OrderViewModel.prototype.singleInstance;
      };
      return OrderViewModel;
    });
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ccKoErrorWrapper.html">ccKoErrorWrapper</a></li><li><a href="module-ccKoExtensions.html">ccKoExtensions</a></li></ul><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="CartViewModel.html">CartViewModel</a></li><li><a href="CCStoreConfiguration.html">CCStoreConfiguration</a></li><li><a href="CheckoutScheduledOrder.html">CheckoutScheduledOrder</a></li><li><a href="delegatedAdminContacts.html">delegatedAdminContacts</a></li><li><a href="DynamicProperty.html">DynamicProperty</a></li><li><a href="DynamicPropertyMetaContainer.html">DynamicPropertyMetaContainer</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="GiftCardViewModel.html">GiftCardViewModel</a></li><li><a href="GiftProductListingViewModel.html">GiftProductListingViewModel</a></li><li><a href="global.html#InfinityViewModel">InfinityViewModel</a></li><li><a href="IntegrationViewModel.html">IntegrationViewModel</a></li><li><a href="ko.bindingHandlers.background.html">background</a></li><li><a href="ko.bindingHandlers.carouselSwipe.html">carouselSwipe</a></li><li><a href="ko.bindingHandlers.ccDateTime.html">ccDateTime</a></li><li><a href="ko.bindingHandlers.ccForm.html">ccForm</a></li><li><a href="ko.bindingHandlers.ccLink.html">ccLink</a></li><li><a href="ko.bindingHandlers.ccValidation.html">ccValidation</a></li><li><a href="ko.bindingHandlers.checkbox.html">checkbox</a></li><li><a href="ko.bindingHandlers.chosen.html">chosen</a></li><li><a href="ko.bindingHandlers.contextResourcesNamespace.html">contextResourcesNamespace</a></li><li><a href="ko.bindingHandlers.currency.html">currency</a></li><li><a href="ko.bindingHandlers.datepicker.html">datepicker</a></li><li><a href="ko.bindingHandlers.datepopover.html">datepopover</a></li><li><a href="ko.bindingHandlers.draggable.html">draggable</a></li><li><a href="ko.bindingHandlers.droppable.html">droppable</a></li><li><a href="ko.bindingHandlers.fade.html">fade</a></li><li><a href="ko.bindingHandlers.hover.html">hover</a></li><li><a href="ko.bindingHandlers.image.html">image</a></li><li><a href="ko.bindingHandlers.imageSource.html">imageSource</a></li><li><a href="ko.bindingHandlers.imageZoom.html">imageZoom</a></li><li><a href="ko.bindingHandlers.localeText.html">localeText</a></li><li><a href="ko.bindingHandlers.makeAccess.html">makeAccess</a></li><li><a href="ko.bindingHandlers.modal.html">modal</a></li><li><a href="ko.bindingHandlers.modalTabbingContraint.html">modalTabbingContraint</a></li><li><a href="ko.bindingHandlers.onRender.html">onRender</a></li><li><a href="ko.bindingHandlers.popeditor.html">popeditor</a></li><li><a href="ko.bindingHandlers.popover.html">popover</a></li><li><a href="ko.bindingHandlers.productImageSource.html">productImageSource</a></li><li><a href="ko.bindingHandlers.productVariantImageSource.html">productVariantImageSource</a></li><li><a href="ko.bindingHandlers.propertyEditor.html">propertyEditor</a></li><li><a href="ko.bindingHandlers.radio.html">radio</a></li><li><a href="ko.bindingHandlers.richTextEditor.html">richTextEditor</a></li><li><a href="ko.bindingHandlers.scrollAffix.html">scrollAffix</a></li><li><a href="ko.bindingHandlers.select2.html">select2</a></li><li><a href="ko.bindingHandlers.select2Tags.html">select2Tags</a></li><li><a href="ko.bindingHandlers.selectable.html">selectable</a></li><li><a href="ko.bindingHandlers.slide.html">slide</a></li><li><a href="ko.bindingHandlers.slider.html">slider</a></li><li><a href="ko.bindingHandlers.spectrum.html">spectrum</a></li><li><a href="ko.bindingHandlers.textCheck.html">textCheck</a></li><li><a href="ko.bindingHandlers.timepicker.html">timepicker</a></li><li><a href="ko.bindingHandlers.triggerMessage.html">triggerMessage</a></li><li><a href="ko.bindingHandlers.validatableTarget.html">validatableTarget</a></li><li><a href="ko.bindingHandlers.validatableValue.html">validatableValue</a></li><li><a href="ko.bindingHandlers.widgetLocaleText.html">widgetLocaleText</a></li><li><a href="koValidation.alphaNumeric.html">alphaNumeric</a></li><li><a href="koValidation.alphaNumericNoSpaces.html">alphaNumericNoSpaces</a></li><li><a href="koValidation.alphaNumericNoSpacesNoDashesWithSeperators.html">alphaNumericNoSpacesNoDashesWithSeperators</a></li><li><a href="koValidation.alphaNumericNoSpacesWithSeperators.html">alphaNumericNoSpacesWithSeperators</a></li><li><a href="koValidation.alphaNumericWithSeperators.html">alphaNumericWithSeperators</a></li><li><a href="koValidation.bool.html">bool</a></li><li><a href="koValidation.creditcard.html">creditcard</a></li><li><a href="koValidation.cvv.html">cvv</a></li><li><a href="koValidation.endmonth.html">endmonth</a></li><li><a href="koValidation.endyear.html">endyear</a></li><li><a href="koValidation.importFileName.html">importFileName</a></li><li><a href="koValidation.laterDate.html">laterDate</a></li><li><a href="koValidation.match.html">match</a></li><li><a href="koValidation.mediaZipFileName.html">mediaZipFileName</a></li><li><a href="koValidation.number.html">number</a></li><li><a href="koValidation.observablePattern.html">observablePattern</a></li><li><a href="koValidation.password.html">password</a></li><li><a href="koValidation.price.html">price</a></li><li><a href="koValidation.propertyIdAlreadyInUse.html">propertyIdAlreadyInUse</a></li><li><a href="koValidation.propertyNameAlreadyInUse.html">propertyNameAlreadyInUse</a></li><li><a href="koValidation.restrictSlashCharacters.html">restrictSlashCharacters</a></li><li><a href="koValidation.startmonth.html">startmonth</a></li><li><a href="koValidation.startyear.html">startyear</a></li><li><a href="koValidation.uniqueTrimmed.html">uniqueTrimmed</a></li><li><a href="koValidation.uniqueTrimmedCaseInsensitive.html">uniqueTrimmedCaseInsensitive</a></li><li><a href="koValidation.url.html">url</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.addTemplate.html">addTemplate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.agentBar.html">agentBar</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDate.html">ccDate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccNumber.html">ccNumber</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccResizeImage.html">ccResizeImage</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.disabled.html">disabled</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.element.html">element</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.embeddedAssistance.html">embeddedAssistance</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.fireChange.html">fireChange</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.inTabFlow.html">inTabFlow</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.noIndexMeta.html">noIndexMeta</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.previewBar.html">previewBar</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.setContextVariable.html">setContextVariable</a></li><li><a href="multiCartViewModel.html">multiCartViewModel</a></li><li><a href="NavStateViewModel.html">NavStateViewModel</a></li><li><a href="OrderDetailsViewModel.html">OrderDetailsViewModel</a></li><li><a href="OrderHistoryViewModel.html">OrderHistoryViewModel</a></li><li><a href="OrdersPendingApprovalViewModel.html">OrdersPendingApprovalViewModel</a></li><li><a href="OrderViewModel.html">OrderViewModel</a></li><li><a href="Organization.html">Organization</a></li><li><a href="ParentOrganisation.html">ParentOrganisation</a></li><li><a href="ProductListingSearchViewModel.html">ProductListingSearchViewModel</a></li><li><a href="ProductListingViewModel.html">ProductListingViewModel</a></li><li><a href="ProductTypes.html">ProductTypes</a></li><li><a href="ProductViewModel.html">ProductViewModel</a></li><li><a href="PromotionUpsellContainer.html">PromotionUpsellContainer</a></li><li><a href="PubSub.topicNames.html">topicNames</a></li><li><a href="PurchaseListListingViewModel.html">PurchaseListListingViewModel</a></li><li><a href="PurchaseListViewModel.html">PurchaseListViewModel</a></li><li><a href="RegistrationRequestSearchViewModel.html">RegistrationRequestSearchViewModel</a></li><li><a href="resetCVV.html">resetCVV</a></li><li><a href="resetGiftCardPin.html">resetGiftCardPin</a></li><li><a href="resetPaymentDetails.html">resetPaymentDetails</a></li><li><a href="ReturnItem.html">ReturnItem</a></li><li><a href="ReturnViewModel.html">ReturnViewModel</a></li><li><a href="scheduledOrderList.html">scheduledOrderList</a></li><li><a href="SearchRestClient.html">SearchRestClient</a></li><li><a href="ServerData.html">ServerData</a></li><li><a href="UserViewModel.html">UserViewModel</a></li><li><a href="WidgetViewModel.html">WidgetViewModel</a></li><li><a href="WishlistContentViewModel.html">WishlistContentViewModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.extenders.html">extenders</a></li><li><a href="koValidation.html">koValidation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addItemToPurchaseList">addItemToPurchaseList</a></li><li><a href="global.html#callWidgetMethodIfApplicable">callWidgetMethodIfApplicable</a></li><li><a href="global.html#CartViewModel#deleteParticularIncompleteOrdersDeletesanincompleteorderbyorderId">CartViewModel#deleteParticularIncompleteOrdersDeletes an incomplete order by orderId</a></li><li><a href="global.html#CCEETagProcessor">CCEETagProcessor</a></li><li><a href="global.html#doesSiteExist">doesSiteExist</a></li><li><a href="global.html#fetchSkuDetailsListError">fetchSkuDetailsListError</a></li><li><a href="global.html#fetchSkuDetailsListSuccess">fetchSkuDetailsListSuccess</a></li><li><a href="global.html#formatSiteText">formatSiteText</a></li><li><a href="global.html#handleInitiateEditSuccess">handleInitiateEditSuccess</a></li><li><a href="global.html#isModified">isModified</a></li><li><a href="global.html#isValidDeterminewhetherornotthepaymentdetailsobjectisvalidbasedonthevalidityofitscomponentparts.Thiswillnotcauseerrormessagestobedisplayedforanyobservablevaluesthatareunchangedandhaveneverreceivedfocusontherelatedformfield(s).">isValidDetermine whether or not the payment details object is validbased on the validity of its component parts. This will notcause error messages to be displayed for any observable valuesthat are unchanged and have never received focus on the related form field(s).</a></li><li><a href="global.html#justFocused">justFocused</a></li><li><a href="global.html#mapProperties">mapProperties</a></li><li><a href="global.html#MENU_CLOSE_TIMEOUT">MENU_CLOSE_TIMEOUT</a></li><li><a href="global.html#populateData">populateData</a></li><li><a href="global.html#populateProductData">populateProductData</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetModified">resetModified</a></li><li><a href="global.html#Resetsstylingforthelazilyloadedimage">Resets styling for the lazily loaded image</a></li><li><a href="global.html#Setsupstylingfortheimagetobelazilyloaded">Sets up styling for the image to be lazily loaded</a></li><li><a href="global.html#ShopperContextViewModel">ShopperContextViewModel</a></li><li><a href="global.html#thelistofpropertiestoignorewhilecopyingdynamicpropertiestoaddressobject">the list of properties to ignore while copying dynamic properties to address object</a></li><li><a href="global.html#validatePaymentDetailsForceallrelevantmemberobservablestoperformtheirvalidationnow&displaytheerrors(ifany)">validatePaymentDetailsForce all relevant member observables to perform theirvalidation now & display the errors (if any)</a></li><li><a href="global.html#WidgetQueue">WidgetQueue</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Wed Feb 26 2020 18:22:22 GMT+0530 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
