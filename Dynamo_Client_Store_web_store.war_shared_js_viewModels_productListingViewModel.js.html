<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Dynamo/Client/Store/web/store.war/shared/js/viewModels/productListingViewModel.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Dynamo/Client/Store/web/store.war/shared/js/viewModels/productListingViewModel.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>
/**
 * @fileoverview Product Listing View Model.
 */
define(
  //-------------------------------------------------------------------
  // PACKAGE NAME
  //-------------------------------------------------------------------
  'viewModels/productListingViewModel',

  //-------------------------------------------------------------------
  // DEPENDENCIES
  //-------------------------------------------------------------------
  ['knockout', 'ccPaginated', 'pubsub', 'ccRestClient', 'ccConstants',
    'CCi18n', 'spinner', 'ccNumber', 'pageLayout/product', 'storageApi', 'pageLayout/site', 'navigation', 'ccStoreConfiguration'],

  function(ko, Paginated, pubsub, ccRestClient, CCConstants, CCi18n, spinner, ccNumber, Product, storageApi, SiteViewModel, navigation, CCStoreConfiguration) {

    "use strict";

    //-------------------------------------------------------
    // View Model
    //-------------------------------------------------------

    /**
     * Represents a product listing, used when handling product collections from category selection.
     *
     * @public
     * @class ProductListingViewModel
     * @extends ccPaginated
     * @param {Product[]} data - The list of products.
     *
     * @property {observable&lt;boolean>} display=true Display results?
     * @property {observable&lt;string>} spanClass The Bootstrap CSS class, determined by the viewport type.
     * @property {string} type='ProductListingViewModel' View model type.
     * @property {Object} productLoadingOptions The options for the 'loading' spinner.
     * @property {integer} itemsPerPage=12 The number of items per page.
     * @property {integer} blockSize=60 The number of items per block.
     * @property {observable&lt;integer>} recordsPerPage=12 The number of records per page;
     * @property {Object[]} currentProducts The current products.
     * @property {string} catalog The current catalog.
     * @property {observable&lt;string>} category The current category.
     * @property {observable&lt;string>} selectedSort The selected sort criteria.
     * @property {observable&lt;string>} resultsText The results text.
     * @property {observable&lt;string>} titleText The title text.
     * @property {observable&lt;integer>} itemsPerRow=4 The number of items per row.
     * @property {integer} itemsPerRowInTabletView=4 The number of items per row in tablet view.
     * @property {integer} itemsPerRowInPhoneView=2 The number of items per row in phone view.
     * @property {integer} itemsPerRowInDesktopView=4 The number of items per row in desktop view.
     * @property {integer} itemsPerRowInLargeDesktopView=4 The number of items per row in large desktop view.
     * @property {CCStoreConfiguration} storeConfiguration An instance of the cc-store-configuration containing store-configuration data.
     */
    function ProductListingViewModel(data) {
      var self = this;

      // call super constructor
      Paginated.call(this);

      //widget object
      self.widget = data;
      self.productGridRefreshOrAppend = true;
      
      self.catalog = ko.observable();

      self.display = ko.observable(true);

      self.showInactiveProducts = null;
      self.showInactiveSkus = null;
      // array to hole Product view models of scrolled products
      self.scrolledViewModels = [];
      // Flag to support scrolling in all view ports, will be set in widget according to configuration
      self.isLoadOnScroll = ko.observable(false);
      // Variable to support backward compatibility to optimize the productgrid rows
      self.productGridExtension = false;
      // Variable to enable client side caching
      self.isCacheEnabled = false;
      // Array to hold clist side cached product view models
      self.cachedViewModels = [];
      // Number of categories to cache on client side
      self.viewModelCacheLimit = 3;
      // flag to refresh the value of ProductGrid when required        
      self.refreshValues=false;

      self.defaultBlockSize = 60;
      self.selectedSort = ko.observable();

      self.categoryOrSearchChanged = false;

      self.changedViaDropDown = false;
      
      // Below map has offsetMap index for each page of category.
      self.pageNumberOffSetIndexMapForCategories = [];

      // Map to hold listing variant of each product type, populated while iterating through products
      self.productTypeListingVariantMap = {};
      
      // These boolean properties help to avoid wrong updates to offset map in local storage.
      this.skipOffSetMapUpdateOnRefresh = false;
      this.skipOffSetMapUpdateOnBrowserBack = false;

      // Previous Get Products endpoint response total items count.
      this.previousGetProductsBlockSize = 0;
      
      if(ccRestClient.profileType == CCConstants.PROFILE_TYPE_AGENT) {
        self.showInactiveProducts = false;
        self.showInactiveSkus = false;
      }

      this.handleResultsPerPage = function(resultsPerPageOption, callback){
        var timeout = setTimeout(this.doChangeResultsPerPage.bind(this, resultsPerPageOption, callback),200);
      };

      /**
       * Change the number of results per page
       * @private
       * @param {Object} resultsPerPage The results per page options.
       * @param {function} callback Callback function.
       */
      this.doChangeResultsPerPage = function(resultsPerPageOption, callback) {
        var itemsPerPage = CCConstants.DEFAULT_ITEMS_PER_PAGE, newBlockSize = this.defaultBlockSize, onPageOne = false;

        if(resultsPerPageOption) {
          this.prevTotalNumber = (this.totalNumber &amp;&amp; this.totalNumber() !== null) ? this.totalNumber() : this.prevTotalNumber;

          if(resultsPerPageOption.id == CCConstants.RESULTS_PER_PAGE_ALL) {
            itemsPerPage = this.prevTotalNumber;
            if(this.blockSize &lt; itemsPerPage) {
              newBlockSize = itemsPerPage;
            }
          } else {
            itemsPerPage = resultsPerPageOption.value;
            if(this.widget &amp;&amp; this.widget.blockSize &amp;&amp; !(isNaN(this.widget.blockSize())) ){
              newBlockSize = parseInt(this.widget.blockSize());
            }
          }

          this.blockSize = newBlockSize;
        }

        // set our new items per page value
        this.itemsPerPage = itemsPerPage;

        if(!this.widget) {
          return;
        }

        this.changedViaDropDown = true;

        if (this.widget.listType() === CCConstants.LIST_VIEW_PRODUCTS) {
          // clean the URL in case it was paged
          this.cleanPage();

          // reset the page number and current page
          this.pageNumber = 1;
          this.currentPage(null);
          this.getPage(1);
        } else if (this.widget.listType() === CCConstants.LIST_VIEW_SEARCH) {
          // clean the URL in case it was paged
          //this.cleanPage();

          if (this.currentPage() == 1){
            onPageOne = true;
          }
          // reset the page number and current page
          this.pageNumber = 1;
          this.currentPage(null);

          if (onPageOne){
            this.getPage(1);
          }else{
            //go back to the first page of results
            navigation.goTo(this.firstPage(), false, true);
          }
         }

         this.changedViaDropDown = false;
      };

      // For mobile and tablet, default view would be scrolling view
      if(($(window)[0].innerWidth || $(window).width()) &lt;= CCConstants.VIEWPORT_TABLET_UPPER_WIDTH){
        self.isLoadOnScroll(true);
      }

      var expandedOffset=0, actualOffset=0, totalExpandedResults=0, totalResults=0;

      // This computed variable gives the BS classes to be put for the
      // product grid.
      self.spanClass = ko.computed(function(){
        var classString = "";
        // The conditions are for checking if the respective class has to be
        // added for that viewport based on the configuration.
        // The first condition states whether the data exists.
        // The second condition removes redundancy if the small viewport
        // has the same class as the larger viewport.
        // This makes it so that the items per row can be made configurable and
        // the products per row changes as per configuration.
        var phoneViewItems = 0,
        tabletViewItems = 0,
        desktopViewItems = 0,
        largeDesktopViewItems = 0;
        if (this.itemsPerRowInPhoneView) {
          phoneViewItems = 12 / this.itemsPerRowInPhoneView;
        }
        if (this.itemsPerRowInTabletView) {
          tabletViewItems = 12 / this.itemsPerRowInTabletView();
        }
        if (this.itemsPerRowInDesktopView) {
          desktopViewItems = 12 / this.itemsPerRowInDesktopView();
        }
        if (this.itemsPerRowInLargeDesktopView) {
          largeDesktopViewItems = 12 / this.itemsPerRowInLargeDesktopView();
        }

        if (phoneViewItems > 0) {
          classString += "col-xs-" + phoneViewItems;
        }
        if ((tabletViewItems > 0) &amp;&amp; (tabletViewItems != phoneViewItems)) {
          classString += " col-sm-" + tabletViewItems;
        }
        if ((desktopViewItems > 0) &amp;&amp; (desktopViewItems != tabletViewItems)) {
          classString += " col-md-" + desktopViewItems;
        }
        if ((largeDesktopViewItems > 0) &amp;&amp; (largeDesktopViewItems != desktopViewItems)) {
          classString += " col-lg-" + largeDesktopViewItems;
        }

        return classString;
      }, self).extend({ deferred: true });

      // additional public variables
      self.type = "ProductListingViewModel";
      // overwrite public methods

      this.productLoadingOptions = {};
      this.productLoadingOptions.parent = '#cc-product-spinner';
      this.productLoadingOptions.selector = '#cc-product-spinner-area';

      /**
       * Remove the 'loading' spinner.
       * @private
       * @instance
       */
      this.removeSpinner = function() {
        var removeDelay = setTimeout(function() {
          $('#cc-product-spinner-area').find('.cc-spinner').remove();}, 500);
      };

      this.handleSorting = function(sorting,cb){
        var timeout = setTimeout(this.doSort.bind(this,sorting,cb),200);

      }

      /**
       * Sort the items.
       * Calls the 'sort' method on the Paginated superclass, and then calls the callback
       * method when finished.
       * @private
       * @param {Object} sorting The sort options.
       * @param {function} cb Callback function.
       */
      this.doSort = function(sorting,cb) {
        if(this.isCacheEnabled) {
          var cachedInex = this.findCachedResultIndex(1);
          if (cachedInex != undefined) {
            this.sortDirectiveOrder(sorting.order());
            this.sortDirectiveProp(sorting.id);
            if(this.currentPage()===1){
              this.currentPage.notifySubscribers();
            }
            this.targetPage = 1;
            this.currentPage(1);
            return;
          }
        }
        this.sort(sorting);

        if(cb) {
          cb(arguments[3]);
        }
      };

      this.itemsPerPage = CCConstants.DEFAULT_ITEMS_PER_PAGE;
      this.blockSize = this.defaultBlockSize;
      
      // This array holds row wise product view models to show in product listing. we will empty it once the row is computed.
      this.pageProductsTemp = [];

      if(this.widget &amp;&amp; this.widget.productsPerPage &amp;&amp; !isNaN(this.widget.productsPerPage()) ){
        this.itemsPerPage = parseInt(this.widget.productsPerPage());
      }
      if(this.widget &amp;&amp; this.widget.blockSize &amp;&amp; !(isNaN(this.widget.blockSize())) ){
        this.blockSize = parseInt(this.widget.blockSize());
      }
      if(this.blockSize &lt;= this.itemsPerPage) {
        this.blockSize = this.itemsPerPage + 1;
      }

      this.recordsPerPage = ko.observable(CCConstants.DEFAULT_ITEMS_PER_PAGE);
      this.lruSize = 100;
      this.numberOfElementsToDelete = 20;
      this.currentProductsComputed = ko.observableArray([]);
      this.currentProducts = ko.computed(function(){

        if (this.widget &amp;&amp; (this.widget.listType() === "product")) {
          var pageProducts = [];
          this.productGridRefreshOrAppend = true;
          var startPosition, endPosition;
          // Get the products in the current page
          startPosition = (this.currentPage() - 1) * this.itemsPerPage;
          endPosition = startPosition + this.itemsPerPage;
          var isLoadOnScroll = this.isLoadOnScroll.peek();
          if(!this.isCacheEnabled){
            var data = this.data.peek();
            pageProducts = data.slice(startPosition, endPosition);
          }

          var products = [];
          var pageProductsLength = pageProducts.length, imageSize, imageUrl;
          var product, listingSku, listingVariant, listingOffsetMap, offsetKeys, offsetLength, sortedOffsetKeys=[];
          if(!self.isLoadOnScroll()){
            self.refreshValues = true;
          }
          if(this.isCacheEnabled) {
            var viewModelsPresent = true;
            var cachedIndex = this.findCachedResultIndex();
            if (cachedIndex != undefined) {
              if (endPosition > this.cachedViewModels[cachedIndex].totalResults) {
                endPosition = this.cachedViewModels[cachedIndex].totalResults;
              }
              for (var i = startPosition; i &lt; endPosition; i++) {
                if (this.cachedViewModels[cachedIndex].viewModels[i] == undefined) {
                  viewModelsPresent = false;
                  break;
                }
              }
              if (viewModelsPresent) {
                this.cachedViewModels[cachedIndex].visitCount++;
                products = this.cachedViewModels[cachedIndex].viewModels.slice(startPosition, endPosition);
                this.currentProductsComputed(products);
                if(isLoadOnScroll){
                  return this.cachedViewModels[cachedIndex].viewModels;
                }
                return products;
              }
              pageProducts = this.cachedViewModels[cachedIndex].products.slice(startPosition, endPosition);
              pageProductsLength = pageProducts.length;
            }
          }
          for (var index = 0; index &lt; pageProductsLength; index++) {
            if (pageProducts[index]) {
              product = new Product(pageProducts[index].product);

              //set up the observable for product listing image
              imageSize = this.listingImageSize();

              // use the primarySmallImageURL, stripping off any dimensions
              imageUrl = product.primarySmallImageURL().match(/.+?(?=&amp;height=)/);

              // if there were no dimensions use the path, otherwise extract the matched string
              imageUrl = imageUrl == null ? product.primarySmallImageURL() : imageUrl[0];

              product.listingImageURL = ko.observable(imageUrl + "&amp;height=" + imageSize + "&amp;width=" + imageSize);

              if ((this.widget.shouldUseStyleBased() || this.widget.shouldUseStyleBased()=="true") &amp;&amp; window.history &amp;&amp; window.history.pushState){
            	  	if (index == 0  &amp;&amp; this.category() &amp;&amp; !this.skipOffSetMapUpdateOnRefresh &amp;&amp; !this.skipOffSetMapUpdateOnBrowserBack) {

                  var listingOffsetMap = storageApi.getInstance().getItem(CCConstants.LISTING_OFFSET_MAP_KEY);
                  if (listingOffsetMap &amp;&amp; typeof listingOffsetMap === 'string') {
                    listingOffsetMap = JSON.parse(listingOffsetMap);
                  }

                  if (listingOffsetMap) {
                    offsetKeys = Object.keys(listingOffsetMap);
                    offsetLength = offsetKeys.length;
                    if (offsetLength &amp;&amp; offsetLength > this.lruSize) {
                      sortedOffsetKeys = offsetKeys.sort(function(a,b){return listingOffsetMap[a].timestamp-listingOffsetMap[b].timestamp});
                      for (var offsetIndex=0; offsetIndex &lt; this.numberOfElementsToDelete; offsetIndex++) {
                        delete listingOffsetMap[sortedOffsetKeys[offsetIndex]];
                      }
                    }
                  } else {
                    listingOffsetMap = {};
                  }
                  // Added below changes to get correct index of the product to update
	              var offsetMapIndex = this.getIndexForOffSetMap();
	               
	              if(offsetMapIndex != null &amp;&amp; this.data()[offsetMapIndex]) {
                    // Getting offsetMap directly from data array based on the actual index value.
	                 this.data()[offsetMapIndex].offsetMap.timestamp=Date.now();
	                 this.data()[offsetMapIndex].offsetMap.offsetMapIndex = offsetMapIndex;
	                    
	                 listingOffsetMap[this.category().route + "/" + this.pageNumber] = this.data()[offsetMapIndex].offsetMap;
	                    
	                 storageApi.getInstance().setItem(CCConstants.LISTING_OFFSET_MAP_KEY, JSON.stringify(listingOffsetMap));
	              }
                }
                var listingVariantOption;
                if(product.productVariantOptions &amp;&amp; product.productVariantOptions().length > 0){
                  // If we already know the listing variant of the product type, get it from productTypeListingVariantMap, otherwise calculate and store in productTypeListingVariantMap
                  if(product.type() in self.productTypeListingVariantMap){
                    listingVariantOption = self.productTypeListingVariantMap[product.type()];
                  }else{
                    ko.utils.arrayForEach(product.productVariantOptions(), function(productVariantOption) {
                      if (productVariantOption.listingVariant() === true) {
                        listingVariantOption =  ko.mapping.toJS(productVariantOption);
                      }
                    });
                    self.productTypeListingVariantMap[product.type()] = listingVariantOption;
                  }
                }
                product.listingSku = pageProducts[index].listingSku;
                if (listingVariantOption) {
                  if (!listingVariantOption.variantBasedDisplay
                    &amp;&amp; pageProducts[index].product.defaultProductListingSku &amp;&amp;
                    pageProducts[index].product.defaultProductListingSku.images &amp;&amp;
                    pageProducts[index].product.defaultProductListingSku.images.length > 0) {
                    product.listingSku = pageProducts[index].product.defaultProductListingSku;
                  }
                  if (product.listingSku) {
                    product.listingSku.route = pageProducts[index].product.route +
                      "?variantName=" +
                      listingVariantOption.optionId +
                      "&amp;variantValue=" +
                      product.listingSku[listingVariantOption.optionId];
                  }
                }
              }
              products.push(product);
              this.pageProductsTemp.push(product);
              //We will not wait until all the product view models are constructed to render the product grid. As a row is complete we would pass it back to the widget to render the grid.
              // when last row is incomplete, in load on scroll mode we will pass it if the total results equal to the sum of already scrolled products and pageProductsTemp
              // in pagination, if the last product index+1 (as index starts from 0) is equal to pageProductsLength, then we will return that incomplete row 
              if(((this.pageProductsTemp.length > 0 &amp;&amp; this.pageProductsTemp.length % this.itemsPerRow() === 0) ||
                ((isLoadOnScroll &amp;&amp; this.totalNumber.peek()===(this.pageProductsTemp.length + this.scrolledViewModels.length)) ||
                (!isLoadOnScroll &amp;&amp; (index + 1) === pageProductsLength)))) {
                this.scrolledViewModels.push.apply(this.scrolledViewModels, this.pageProductsTemp);
                if(!this.productGridExtension &amp;&amp; (this.viewportMode() == CCConstants.TABLET_VIEW ||this.viewportMode() == CCConstants.PHONE_VIEW)){
                  this.currentProductsComputed(this.scrolledViewModels);
                }else {
                  this.currentProductsComputed(this.pageProductsTemp.splice(0));
                }
                this.pageProductsTemp = [];
                this.productGridRefreshOrAppend = false;
              }
            }
          }
          
          var selectedCategory = this.category();
          if(selectedCategory &amp;&amp; cachedIndex!=undefined &amp;&amp; this.isCacheEnabled){
            for(var i = 0; i&lt; products.length; i++){
              this.cachedViewModels[cachedIndex].viewModels[i+startPosition] = products[i];
            }
          }
          if(isLoadOnScroll){
              return this.scrolledViewModels;
          }
          // This makes the page focus outlike the product-listing as appear as the page is stuck on ipad and iphone.
          // $('#CC-product-listing-sortby').focus();

          return products;
        }
      }, this).extend({ deferred: true });


      /**
       * Check the size of the current viewport and set the viewport
       * mode accordingly.
       * @private
       * @param {integer} viewportWidth The viewport width.
       **/
      this.checkResponsiveFeatures = function(viewportWidth) {
        if(viewportWidth > CCConstants.VIEWPORT_LARGE_DESKTOP_LOWER_WIDTH) {
          if(self.viewportMode() != CCConstants.LARGE_DESKTOP_VIEW) {
            self.viewportMode(CCConstants.LARGE_DESKTOP_VIEW);
            self.handleViewportChange(CCConstants.LARGE_DESKTOP_VIEW);
          }
        }
        else if(viewportWidth > CCConstants.VIEWPORT_TABLET_UPPER_WIDTH  &amp;&amp; viewportWidth &lt;= CCConstants.VIEWPORT_LARGE_DESKTOP_LOWER_WIDTH) {
          if(self.viewportMode() != CCConstants.DESKTOP_VIEW) {
            self.viewportMode(CCConstants.DESKTOP_VIEW);
            self.handleViewportChange(CCConstants.DESKTOP_VIEW);
          }
        }
        else if(viewportWidth >= CCConstants.VIEWPORT_TABLET_LOWER_WIDTH &amp;&amp; viewportWidth &lt;= CCConstants.VIEWPORT_TABLET_UPPER_WIDTH){
          if(self.viewportMode() != CCConstants.TABLET_VIEW) {
            self.viewportMode(CCConstants.TABLET_VIEW);
            self.handleViewportChange(CCConstants.TABLET_VIEW);
          }
        }
        else if(self.viewportMode() != CCConstants.PHONE_VIEW) {
          self.viewportMode(CCConstants.PHONE_VIEW);
          self.handleViewportChange(CCConstants.PHONE_VIEW);
        }
      };
      
      /**
       * This method returns index value of product in product data based on the blocksize.
       * 
       * */
      this.getIndexForOffSetMap = function () {  
    	  	
        var defaultProductsPerPage = this.itemsPerPage;
    	    
    	if(this.widget &amp;&amp; this.widget.productsPerPage &amp;&amp; !isNaN(this.widget.productsPerPage())) {
          defaultProductsPerPage = parseInt(this.widget.productsPerPage());
    	}
    	    // Currently not setting offset map incase it is not changed from default products per page.
		if(this.itemsPerPage !== defaultProductsPerPage) {
		  return null;
		}

		// In case default sort option is changed, ignore to reset offset map in local storage.
        if(this.sortOptions &amp;&amp; this.sortOptions() &amp;&amp;
           this.sortOptions().length > 0 &amp;&amp; this.sortOptions()[0] &amp;&amp;
           this.sortOptions()[0] !== this.selectedSort())  {
          return null;
        }

		var categoryPageNumberOffSetIndexMap = null;  
		
		for(var index = 0; index &lt; this.pageNumberOffSetIndexMapForCategories.length; index++) {          
		   if(this.pageNumberOffSetIndexMapForCategories[index].categoryId === this.category().id) {
		     categoryPageNumberOffSetIndexMap = this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap;
		     break;
		   }
		 }
		 
		 // When pageNumberOffSetIndexMap is not defined, dont update offsetMap.
         if(!categoryPageNumberOffSetIndexMap) {
		   return null;
		 }
		 
		 if(this.totalExpandedResults &lt;= this.itemsPerPage) {
		     return this.data().length - 1;
		 }
		  
		 for(var i = 0; i &lt; categoryPageNumberOffSetIndexMap.length; i++) {
		    var previousPageOffSetIndex = null;
		      
		    if( i > 0 ) {
		      previousPageOffSetIndex = categoryPageNumberOffSetIndexMap[i-1].offSetIndex;
		    } 
		      
		    if(this.pageNumber === categoryPageNumberOffSetIndexMap[i].pageNumber) {
		       return categoryPageNumberOffSetIndexMap[i].offSetIndex;
		    } else if(this.pageNumber &lt; categoryPageNumberOffSetIndexMap[i].pageNumber &amp;&amp; previousPageOffSetIndex
		             &amp;&amp; categoryPageNumberOffSetIndexMap[i-1].pageNumber >= this.pageNumber) {
		    	   // In case page number is between the offset indexes.
		       return previousPageOffSetIndex;
		    }
		  }
		 
		  // In case offset map is not present in map and totalExpandedResults and data length is same.
		  if((this.totalExpandedResults === this.data().length &amp;&amp; categoryPageNumberOffSetIndexMap.length > 0) || 
		    categoryPageNumberOffSetIndexMap.length == 1) {
		        return categoryPageNumberOffSetIndexMap[categoryPageNumberOffSetIndexMap.length - 1].offSetIndex;
		  }
		return null;
      } 

      /**
       * Set the number of items per row for responsive viewports
       * (tablet and phone).
       * @private
       */
      this.handleResponsiveViewports = function() {
        if(self.viewportMode() == CCConstants.TABLET_VIEW) {
          self.itemsPerRow(self.itemsPerRowInTabletView());
          self.isMobileView(true);
          self.isLoadOnScroll(true);
        }
        if(self.viewportMode() == CCConstants.PHONE_VIEW) {
          self.itemsPerRow(self.itemsPerRowInPhoneView);
          self.isMobileView(true);
          self.isLoadOnScroll(true);
        }
        self.refreshValues=true;
        self.scrolledViewModels = [];
        if(self.isLoadOnScroll()){
          // Computing current products in case of scrollable view as fetchBlock is not called
          if(self.productGridExtension){
            if(self.currentPage() === 1){
              self.currentPage.notifySubscribers();
            } else {
              self.currentPage(1);
            }
          }
          self.scrollToTop = false;
        } else {
          self.scrollToTop = true;
        }
      };

      /**
       * Adds and removes scroll event handler from window, based on what
       * viewport mode we're in.
       * @private
       * @param {integer} value The viewport mode.
       */
      this.handleViewportChange = function(value) {
    	var initial= self.itemsPerRow();
        if(value == self._internalViewportMode()) return;

        if (value) {
          self._internalViewportMode(value);
        }
        if(self.viewportMode() == CCConstants.DESKTOP_VIEW) {
    
          self.itemsPerRow(self.itemsPerRowInDesktopView());
          self.clearOnLoad = true;
          self.targetPage = 1;
          self.fetchBlock(0);
          self.isMobileView(false);
          self.isLoadOnScroll(false);
        }
        else if(self.viewportMode() == CCConstants.LARGE_DESKTOP_VIEW) {

          self.itemsPerRow(self.itemsPerRowInLargeDesktopView());
          self.clearOnLoad = true;
          self.targetPage = 1;
          self.fetchBlock(0);
          self.isMobileView(false);
          self.isLoadOnScroll(false);
        }
        self.handleResponsiveViewports();
      };

      this.pageNumberDeferred = $.Deferred();
      /**
       * Handles calculation of pagination links for SEO rel tags.
       *
       * @param {viewModel} instance of ProductListingViewModel
       * @param {data} PAGE_PAGINATION_CHANGE event data
       */
      this.handleLinks = function(viewModel, data) {
        var pagesCount = viewModel.totalNumberOfPages();
        var currentPage = parseInt(data.page) || (data.paginationOnly ? 1 : viewModel.pageNumber);
        var curr, prev;

        if (pagesCount == 1 || currentPage == 1) {
          prev = null;
          curr = '';
        } else {
          prev = "/" + (currentPage - 1);
          curr = "/" + currentPage;
        }

        $.Topic(pubsub.topicNames.PAGE_PAGINATION_CALCULATED).publish({
          currPageNo: curr,
          prevPageNo: prev,
          nextPageNo: (pagesCount == 1 || currentPage == pagesCount) ? null : '/' + (currentPage + 1)
        });
      };
      /**
       * Handles PAGE_PAGINATION_CHANGE pub sub event.
       *
       * @param {data} PAGE_PAGINATION_CHANGE event data
       */
      this.handlePaginationChange = function(data) {
        this.pageNumberDeferred.resolve(this, data);
        if (data.paginationOnly) {
          this.handleLinks(this, data);
        }
      };
      // subscribe to the pubsub event
      $.Topic(pubsub.topicNames.PAGE_PAGINATION_CHANGE).subscribe(this.handlePaginationChange.bind(this));

      this.checkResponsiveFeatures($(window)[0].innerWidth || $(window).width());
      this.handleResponsiveViewports();

      this._internalViewportMode(this.viewportMode());

      this.resultsText = ko.computed(this.getResultsText, this);
      this.storeConfiguration = CCStoreConfiguration.getInstance();
    }

    var Temp = function(){};
    Temp.prototype = Paginated.prototype;

    ProductListingViewModel.prototype = new Temp();

    // setup the inheritance chain
    ProductListingViewModel.prototype.constructor = ProductListingViewModel;

    ProductListingViewModel.prototype.category = ko.observable();
    ProductListingViewModel.prototype.resultsText = ko.observable();
    ProductListingViewModel.prototype.titleText = ko.observable();
    ProductListingViewModel.prototype.itemsPerRow = ko.observable(4);
    ProductListingViewModel.prototype.itemsPerRowInTabletView = ko.observable(4);
    ProductListingViewModel.prototype.itemsPerRowInPhoneView = 2;
    ProductListingViewModel.prototype.itemsPerRowInDesktopView = ko.observable(4);
    ProductListingViewModel.prototype.itemsPerRowInLargeDesktopView = ko.observable(4);
    ProductListingViewModel.prototype._internalViewportMode = ko.observable(4);
    ProductListingViewModel.prototype.viewportMode = ko.observable(4);
    ProductListingViewModel.prototype.spanClass = ko.observable();
    ProductListingViewModel.prototype.listingImageSize = ko.observable(300);

    /**
     * Resets the sort by drop down and user selected sort option.
     */
    ProductListingViewModel.prototype.resetSortOptions = function() {
      // Setting displayName id as default sort.
      var defaultSortOption = this.sortOptions()[0];
      this.selectedSort(defaultSortOption);
      this.sortDirectiveProp(defaultSortOption.id);
      this.sortDirectiveOrder(defaultSortOption.order("none"));
    };

    /**
     * Clear function to reset all the local data
     * and associated metadata.
     * @private
     */
    ProductListingViewModel.prototype.clearData = function() {
      this.data([]);
      this.prevTotalNumber = this.totalNumber();
      this.totalNumber(null);
      this.actualOffset=0;
      this.expandedOffset=0;
      this.scrolledViewModels = [];
    };

    /**
     * Gets the specified page of results. Will fetch needed results if they
     * are not already loaded.
     * @param {integer} pageNumber The page number of results to get.
     * @private
     * @function productListingViewModel#getPage
     */
    ProductListingViewModel.prototype.getPage = function(pageNumber) {
      if (this.totalNumberOfPages() > 1) {
        this.adjustPageIndex(pageNumber);
      }
      this.adjustStartAndEndPageIndex(pageNumber);
      // Pagination for mobile views
      if(pageNumber !== this.currentPage() &amp;&amp; pageNumber !== this.targetPage &amp;&amp; this.isMobileView()) {
        $.Topic(pubsub.topicNames.RECORD_PAGINATION_PAGE_CHANGE).publish();
      }
      // Populate all missing items on the page
      if (pageNumber !== this.targetPage || this.targetPage === null || this.targetPage === undefined) {
        this.targetPage = pageNumber;
      }
      if(this.isCacheEnabled) {
        var getData = false;
        var cachedIndex = this.findCachedResultIndex(pageNumber);
        if (cachedIndex == undefined) {
          getData = true;
        } else {
          var pageEndIndex = this.pageEndIndex();
          if(pageEndIndex > this.cachedViewModels[cachedIndex].totalResults){
            pageEndIndex = this.cachedViewModels[cachedIndex].totalResults;
          }
          for (var i = this.pageStartIndex(); i &lt; pageEndIndex; i += 1) {
            if (typeof this.cachedViewModels[cachedIndex]["products"][i] === 'undefined') {
              getData = true;
              break;
            }
          }
        }
        if (getData) {
          if (pageNumber !== this.currentPage()) {
            this.targetPage = pageNumber;
          }
          this.fetchBlock(this.pageStartIndex());
          return;
        }
        if(this.currentPage() === pageNumber){
          this.currentPage.notifySubscribers();
        }
        this.totalNumber(this.cachedViewModels[cachedIndex].totalResults);
        $.when(this.pageNumberDeferred).done(this.handleLinks);
        this.titleText(this.getTitleText());
      } else {
        if (this.clearOnLoad) {
          this.fetchBlock(this.pageStartIndex());
          this.clickedPage(pageNumber);
          this.currentPage(pageNumber);
          return;
        }
        for (var i = this.pageStartIndex(); i &lt; this.pageEndIndex(); i += 1) {
          if (typeof this.data()[i] === 'undefined') {
            if(pageNumber !== this.currentPage()) {
              this.targetPage = pageNumber;
            }
            this.fetchBlock(this.pageStartIndex());
            return;
          }
        }
      }
      this.currentPage(pageNumber);
    };

    /**
     * finds the index of cached category
     * @private
     * @function productListingViewModel#findCachedResultIndex
     */
    ProductListingViewModel.prototype.findCachedResultIndex = function(){
      var cachedIndex;
      var selectedCategory = this.category.peek();
      var selectedSort = this.selectedSort.peek();
      for(var i=0; i&lt; this.cachedViewModels.length; i++){
        if(this.cachedViewModels[i] &amp;&amp; this.cachedViewModels[i]["categoryId"] == selectedCategory.repositoryId &amp;&amp;
          this.cachedViewModels[i]["sortKey"] == selectedSort.id &amp;&amp; this.cachedViewModels[i]["sortOrder"] == selectedSort.order()){
          cachedIndex = i;
          break;
        }
      }
      return cachedIndex;
    };

    /**
     * Load products using the current sorting order and starting from the
     * specified starting index.
     * @param {integer} startingIndex the index of the first record to load.
     */
    ProductListingViewModel.prototype.fetchBlock = function(startingIndex) {
      var url, data;

      if(this.clearOnLoad) {
        this.titleText('');
        this.clearData();
      }

      data = {};
      data[CCConstants.TOTAL_RESULTS] = true;
      data[CCConstants.TOTAL_EXPANDED_RESULTS] = CCStoreConfiguration.getInstance().PRODUCT_LISTING_TOTAL_EXPANDED_RESULTS !== undefined ?
          (String(CCStoreConfiguration.getInstance().PRODUCT_LISTING_TOTAL_EXPANDED_RESULTS)==="true" ? true : false) : true;
      if(this.catalog) {
        data[CCConstants.CATALOG] = this.catalog();
      }
      if (this.widget.user &amp;&amp; this.widget.user().catalogId){
        data[CCConstants.CATALOG] = this.widget.user().catalogId();
      }
      
      data[CCConstants.LIMIT] = this.blockSize;
      
      if ((this.widget.shouldUseStyleBased() || this.widget.shouldUseStyleBased()=="true") &amp;&amp; window.history &amp;&amp; window.history.pushState) {
        if (startingIndex == 0) { //first page data
          this.actualOffset = 0;
          this.expandedOffset = 0;
          data[CCConstants.OFFSET] = this.actualOffset;
        } 
        else if(this.data()[startingIndex]) {
  	        for (var index=1; index &lt;= this.blockSize; index++) {
              if (this.data()[startingIndex + this.itemsPerPage - index]) {
                if(this.skipOffSetMapUpdateOnRefresh) {
                  this.actualOffset = this.data()[startingIndex + this.itemsPerPage - index].offsetMap.actualOffset + this.previousGetProductsBlockSize;
                } else {
                  this.actualOffset = this.data()[startingIndex + this.itemsPerPage - index].offsetMap.actualOffset + this.blockSize;
				  if(this.actualOffset > this.totalNumber.peek()) {
                      this.actualOffset= startingIndex; //Fix for CCSF-17680
                  }
                }
                this.expandedOffset = startingIndex + this.itemsPerPage + 1 - index;
                data[CCConstants.OFFSET] = this.actualOffset;
                break;
              }
            }
            if (data[CCConstants.OFFSET] == undefined) {
              for (var index=1; index &lt;= this.blockSize; index++) {
                if (this.data()[startingIndex + index]) {
                  this.actualOffset = (this.data()[startingIndex + index].offsetMap.actualOffset - this.blockSize) &lt; 0 ?
                    0 : (this.data()[startingIndex + index].offsetMap.actualOffset - this.blockSize);
                  this.expandedOffset = -1 * (startingIndex + index -1);
                  data[CCConstants.OFFSET] = this.actualOffset;
                  break;
                }
              }
            }
          }


        if (data[CCConstants.OFFSET] == undefined) {
  	      var offsetMap, listingOffsetMap;
  	
  	      var defaultProductsPerPage = this.itemsPerPage;
	    
	      if(this.widget &amp;&amp; this.widget.productsPerPage &amp;&amp; !isNaN(this.widget.productsPerPage())) {
	        defaultProductsPerPage = parseInt(this.widget.productsPerPage());
	      }
	    
	      if(this.itemsPerPage === defaultProductsPerPage) {
  	         listingOffsetMap = storageApi.getInstance().getItem(CCConstants.LISTING_OFFSET_MAP_KEY);
  	         if (listingOffsetMap &amp;&amp; typeof listingOffsetMap === 'string') {
  	           listingOffsetMap = JSON.parse(listingOffsetMap);
  	         }
  	       }
  	       if (listingOffsetMap) {
  	         offsetMap = listingOffsetMap[this.category().route + "/" + this.pageNumber];
  	         // When publish time is different from previous saved value.
  	         if(offsetMap &amp;&amp; !isNaN(ccRestClient.lastPublishedTimeStamp) &amp;&amp;
  	  	        new Date(parseInt(ccRestClient.lastPublishedTimeStamp)) > new Date(offsetMap.timestamp)) {
  	  	       offsetMap = undefined;
  	  	     }
  	       }
  	       if (offsetMap &amp;&amp; offsetMap !== undefined) {
  	         
  	         var isBlockSizeMultipeOfPageSize = 0;
  	          
  	         if(offsetMap.actualOffset != 0) {
  	           if(this.itemsPerPage > this.blockSize) {
  	              isBlockSizeMultipeOfPageSize = this.itemsPerPage % this.blockSize;
  	            } else {
  	              isBlockSizeMultipeOfPageSize = this.blockSize % this.itemsPerPage;
  	            }
  	          } 
  	          
  	          if(isBlockSizeMultipeOfPageSize === 0) {
  	            this.actualOffset= offsetMap.actualOffset;
  	            this.expandedOffset = offsetMap.expandedOffset;
  	            data[CCConstants.OFFSET] = this.actualOffset;
  	          } else {
  	            // Browser back from PDP to PLP scenario and offset of the current page starts from middle.
  	            var previousPageOffsetMap = listingOffsetMap[this.category().route + "/" + (this.pageNumber - 1)];
  	            this.actualOffset = previousPageOffsetMap.actualOffset;
  	            this.expandedOffset = previousPageOffsetMap.expandedOffset;
  	            data[CCConstants.OFFSET] = this.actualOffset;
  	            if(!this.data()[this.actualOffset + this.blockSize]) {
  	              data[CCConstants.LIMIT] = (this.blockSize * 2);
  	            }
  	            this.skipOffSetMapUpdateOnBrowserBack = true;
  	          }
  	        } else if (this.data().length == 0) {
  	          // Hard refresh on a specific page.
  	          this.actualOffset = 0;
  	          this.expandedOffset = 0;
  	          data[CCConstants.OFFSET] = this.actualOffset;
  	          data[CCConstants.LIMIT] = (this.itemsPerPage * (this.pageNumber || 1));
  	          this.skipOffSetMapUpdateOnRefresh = true;
  	       } else if(this.data().length !== ((this.pageNumber - 1) * this.itemsPerPage)){
  	          // Moving to last page from first page.
  	          this.actualOffset = this.data()[this.data().length-1].offsetMap.actualOffset + this.previousGetProductsBlockSize - 1;
  	          this.expandedOffset = this.data().length - 1;
  	          data[CCConstants.OFFSET] = this.actualOffset;
  	          data[CCConstants.LIMIT] = (this.itemsPerPage * (this.pageNumber || 1));
  	          this.skipOffSetMapUpdateOnRefresh = true;
  	       }
  	    }
      }


      if (data[CCConstants.OFFSET] == undefined) {
        this.actualOffset = startingIndex;
        this.expandedOffset = startingIndex;
        data[CCConstants.OFFSET] = this.actualOffset;
      }


      if (this.sortDirectiveProp() !== 'default') {
        data[CCConstants.SORTS] = this.sortDirectiveProp() + ":" + this.sortDirectiveOrder();
      }

      url = CCConstants.ENDPOINT_PRODUCTS_LIST_PRODUCTS;

      if(this.category()) {

    	if ((!this.requesting) || (this.currentRequest!=this.category().id)) {
          this.requesting = true;
          spinner.create(this.productLoadingOptions);

          data[CCConstants.CATEGORY] = this.category().id;
          this.currentRequest = this.category().id;
          data.includeChildren = true;
          if(this.showInactiveProducts != null &amp;&amp; this.showInactiveSkus != null) {
            data.showInactiveProducts = this.showInactiveProducts;
            data.showInactiveSkus = this.showInactiveSkus;
          }

          if (this.widget &amp;&amp; this.widget.fields &amp;&amp; this.widget.fields()){
            data.fields = this.widget.fields();
          }
          this.requesting = true;
          data[CCConstants.STORE_PRICELISTGROUP_ID] = SiteViewModel.getInstance().selectedPriceListGroup().id;

          if (this.widget &amp;&amp; this.widget.productListing &amp;&amp; this.widget.productListing.filterKey) {
            data[CCConstants.FILTER_KEY] = this.widget.productListing.filterKey;
          }
          // add query params from the map.
          if(this.widget &amp;&amp; this.widget.productListingQueryParams &amp;&amp; this.widget.productListingQueryParams.size > 0) {
            this.widget.productListingQueryParams.forEach(function(value, key) {
              data[key]=value;
            });
          }
          ccRestClient.request(url, data,
        	  function(result){this.successFunc(result);}.bind(this),
//            this.successFunc.bind(this),
            this.errorFunc.bind(this));
        }
      }
    };


    ProductListingViewModel.prototype.buildResultsPerPageOption = function(value, allResults) {
      return {
        'id':           allResults ? CCConstants.RESULTS_PER_PAGE_ALL : 'rec-per-page-' + value,
        'displayText':  allResults ?  CCi18n.t('ns.productlisting:resources.resultsPerPageOptionAll') : value,
        'value':        value
      };
    };

    /**
     * Build the Results Per Page data
     * Adds the product data to the view model.
     * @private
     * @param {Object} result The products result object.
     * @param {Object} previously selected results per page option
     * @param {Object} previous total results count
     */
    ProductListingViewModel.prototype.buildResultsPerPage = function(currentTotalResults, previousTotalResults, prevSelectedResultsPerPageOption) {
      var vm = this;

      // don't process it if the results per page option has not been selected or
      // the property doesn't exist for the version of the widget (CCSF-11824)
      if(!vm.widget.showResultsPerPageSection || !vm.widget.showResultsPerPageSection()) {
        return;
      }

      var newResultsPerPageOptions = [],
          recordsPerPageVal = 0,
          itemsPerPage = (vm.widget.productsPerPage &amp;&amp; vm.widget.productsPerPage()) || CCConstants.DEFAULT_ITEMS_PER_PAGE;

      if (!this.resultsPerPageOptions().length || this.categoryOrSearchChanged) {
        this.categoryOrSearchChanged = false;
        // loop through the series and create results per page options
        $.each(CCConstants.RESULTS_PER_PAGE_SERIES, function(i, val) {
          //skip the first entry as we will always add ALL
          if(i == 0) {
            return;
          }

          recordsPerPageVal = itemsPerPage * val;

          if(recordsPerPageVal &lt; currentTotalResults) {
            newResultsPerPageOptions.push(vm.buildResultsPerPageOption(recordsPerPageVal));
          }
        });

        newResultsPerPageOptions.push(vm.buildResultsPerPageOption(currentTotalResults, true));
        this.resultsPerPageOptions(newResultsPerPageOptions);
      }
    };

    /**
     * 'Load products' success callback function.
     * Adds the product data to the view model.
     * @private
     * @param {Object} result The products result object.
     */
    ProductListingViewModel.prototype.successFunc = function(result) {
      var prevSelectedResultsPerPageOption = this.selectedResultsPerPageOption(),
          prevTotalResultsCount = this.prevTotalNumber;

      if ((this.widget.shouldUseStyleBased() || this.widget.shouldUseStyleBased()=="true") &amp;&amp; window.history &amp;&amp; window.history.pushState) {
        this.totalExpandedResults = result.totalExpandedResults;
        this.totalResults = result.totalResults;
        
    	
        this.previousGetProductsBlockSize = result.limit;

        // generate the results per page data
        this.buildResultsPerPage(this.totalExpandedResults, prevTotalResultsCount, prevSelectedResultsPerPageOption);

        // Total Number Block sizes retrieved at one request
        var totalNumberOfBlockSizes = this.previousGetProductsBlockSize/this.blockSize;
        
        var expandedProducts = [];
        var currentExpandedOffset = 0;
        
        // Expand products in each batch size to calculate offset and expand offset value correctly for that block size.
        for(var i = 0; i &lt; totalNumberOfBlockSizes; i++) {
          var offsetMap = {};
          offsetMap.actualOffset = result.offset + (this.blockSize * i);
          var currentBlockExpandedProducts = this.expandProducts(result.items.slice(i * this.blockSize, ((i+1) * this.blockSize)), offsetMap);
          
          var currentBlockExpandedOffset;

          if (this.expandedOffset >= 0) {
        	currentBlockExpandedOffset = this.expandedOffset + expandedProducts.length;
          } else {
        	currentBlockExpandedOffset = (Math.abs(this.expandedOffset) - expandedProducts.length) - currentBlockExpandedProducts.length;
          }
          offsetMap.expandedOffset = currentBlockExpandedOffset; //It updates the object value which is tied to all expanded products
          
          expandedProducts = expandedProducts.concat(currentBlockExpandedProducts);
        }
        
        if (this.expandedOffset >= 0) {
          currentExpandedOffset = this.expandedOffset;
        } else {
    	  currentExpandedOffset = (Math.abs(this.expandedOffset) - expandedProducts.length);
        }
        
        if (expandedProducts &amp;&amp; expandedProducts.length > 0) {
          if(this.isCacheEnabled){
            this.populateData(expandedProducts, result.totalExpandedResults, currentExpandedOffset);
          }
          
          this.addData(expandedProducts, result.totalExpandedResults &lt; 0 ? 0
            : result.totalExpandedResults, currentExpandedOffset);
          
          if(this.pageNumber > this.totalNumberOfPages()) {
            // Passing in true for noHistory param (2nd param), we don't want the url to change on 404 pages.
            navigation.goTo(this.widget.links()['404'].route, true, true);
          }
          var insertNextPageNumberOffset = false;
          
          // This condition is added to insert next page offSetMap index when current page loads next page data exactly matching.
          if(this.data().length == ((this.pageNumber + 1) * this.itemsPerPage)) {
              insertNextPageNumberOffset = true;
          }
          
          if(this.pageNumberOffSetIndexMapForCategories) {
	        var found = false;
	          
	        var pageNumber = this.pageNumber;
	          
	  	    var productsPerPage = this.itemsPerPage;
	  	    
		    if(this.widget &amp;&amp; this.widget.productsPerPage &amp;&amp; !isNaN(this.widget.productsPerPage())) {
		      productsPerPage = parseInt(this.widget.productsPerPage());
		    }

	        if(this.itemsPerPage !== productsPerPage) {
	              
	          if(productsPerPage > parseInt(this.itemsPerPage)) {
	            // 12 vs 48
	            pageNumber =  this.pageNumber - Math.ceil(productsPerPage/this.itemsPerPage);
	          } else {
	            // 48 vs 12
	            pageNumber = this.pageNumber + Math.ceil(Math.abs(productsPerPage/this.itemsPerPage));
	          }
		    }
	         
	        for(var index = 0; index &lt; this.pageNumberOffSetIndexMapForCategories.length; index++) {  
	          if(this.pageNumberOffSetIndexMapForCategories[index].categoryId === this.category().id) {
    	               
	            var pageNumberFound = false;
	            	
	            for(var j=0; j&lt;this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.length; j++) {
	              if(this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap[j].pageNumber === pageNumber) {
	                pageNumberFound = true;
	                break;
	              }
	            }
	            if(!pageNumberFound) {
	              this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.push({
	                                                                          pageNumber: pageNumber, 
	                                                                          offSetIndex: this.data().length - 1
	                                                                      });
	            }
	              
	            pageNumberFound = false;
	              
	            if(insertNextPageNumberOffset) {
	              // Repeating for loop to avoid complex scenarios.
	              for(var j=0; j&lt;this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.length; j++) {

	                if(this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap[j].pageNumber === (pageNumber + 1)) {
    	                  pageNumberFound = true;
	                  break;
	                }
	              }
	              if(!pageNumberFound) {
	                this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.push({
	                                                                          pageNumber: pageNumber + 1, 
	                                                                          offSetIndex: this.data().length - 1
	                                                                      });
	               }
	             }
	              
	             pageNumberFound = false;
	              
	             this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap = 
	                        this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.sort(
	                            function compare(offSetMap1, offSetMap2) {
                                     return offSetMap1.pageNumber - offSetMap2.pageNumber;
                                });
	              
	             found = true;
	             break;
    	            
	           }
	         }
	            
	         if(!found) {
	        	   
	        	   var listingOffsetMap = storageApi.getInstance().getItem(CCConstants.LISTING_OFFSET_MAP_KEY);
	        	   
	           this.pageNumberOffSetIndexMapForCategories.push({
	                                                              categoryId: this.category().id,
	                                                              pageNumberOffSetIndexMap: 
	                                                              [
	                                                                  {
	                                                                      pageNumber: this.pageNumber, 
	                                                                      offSetIndex: this.data().length - 1
	                                                                  }
	                                                              ]
	                                                             });
	           if(this.pageNumber != 1 &amp;&amp; listingOffsetMap) {
	        	     for(var i=1; i&lt;=this.totalNumberOfPages(); i++) {
	            		if(i !== this.pageNumber) {
		            	  var currentPageOffsetMap = listingOffsetMap[this.category().route + "/" + i];
		            	  if(currentPageOffsetMap &amp;&amp; currentPageOffsetMap.offsetMapIndex) {
		            		 this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.push({
	                                                                                  pageNumber: j, 
	                                                                                  offSetIndex: currentPageOffsetMap.offsetMapIndex
	                                                                              });
	                   }
	            		}
	            	  }
	           }
	           
	           this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap = 
                     this.pageNumberOffSetIndexMapForCategories[index].pageNumberOffSetIndexMap.sort(
                         function compare(offSetMap1, offSetMap2) {
                              return offSetMap1.pageNumber - offSetMap2.pageNumber;
                         });
	         }
          }

        } else {
          // Passing in true for noHistory param (2nd param), we don't want the url to change on 404 pages.
          navigation.goTo(this.widget.links()['404'].route, true, true);
        }
      } else {
        // generate the results per page data
        this.totalResults = result.totalResults;
        this.buildResultsPerPage(this.totalResults, prevTotalResultsCount, prevSelectedResultsPerPageOption);

        var items = [];
        if(result &amp;&amp; result.items &amp;&amp; result.items.length > 0){
          for (var index = 0, prodLength = result.items.length; index &lt; prodLength; index++) {
            var obj = {};
            obj.product = result.items[index];
            items[index] = obj;
          }
        } else {
          navigation.goTo(this.widget.links()['404'].route, true, true);
        }

        if(this.isCacheEnabled) {
          this.populateData(items, result.totalResults, result.offset);
        }
        this.addData(items, result.totalResults &lt; 0 ? 0 : result.totalResults, result.offset);

      }

      // tell the deferred method that it can now calculate SEO links
      $.when( this.pageNumberDeferred ).done(this.handleLinks);
      this.removeSpinner();
      this.titleText(this.getTitleText());
      this.requesting = false;
    };

    /**
     * 'Load products' error callback function.
     * @private
     * @param {Object} result The error object.
     */
    ProductListingViewModel.prototype.errorFunc = function(result) {
      this.removeSpinner();
      this.requesting = false;
    };

    /**
     * Adds the product data to the cached array when cache is enabled.
     * @private
     * @param {Object} items The products result object.
     * @param {Integer} totalResults total number of products.
     * @param {Object} startIndex starting position after which products should be added in the cached array.
     */
    ProductListingViewModel.prototype.populateData = function(items, totalResults, startIndex){
      var ii, dataSet;
      var cachedIndex = this.findCachedResultIndex();
      if(cachedIndex == undefined){
        dataSet = [];
        for(ii = 0; ii &lt; items.length; ii += 1) {
          dataSet[ii + startIndex] = items[ii];
        }
        this.cachedViewModels.push({
          "categoryId": this.category().repositoryId,
          "viewModels": [],
          "visitCount": 0,
          "sortKey": this.selectedSort().id,
          "sortOrder": this.selectedSort().order(),
          "products": dataSet,
          "totalResults": totalResults
        });
        // If cache limit is reached, then delete the oldest category visited
        if(this.cachedViewModels.length > this.viewModelCacheLimit){
          this.cachedViewModels.splice(0, 1);
        }
      } else {
        dataSet = this.cachedViewModels[cachedIndex].products;
        for(ii = 0; ii &lt; items.length; ii += 1) {
          dataSet[ii + startIndex] = items[ii];
        }
        this.cachedViewModels[cachedIndex].products = dataSet;
        this.cachedViewModels[cachedIndex].viewModels.splice(startIndex);
      }
      return;
    };

    /**
     * Expand all the products depending upon product level ordering
     * or product type level ordering.
     * Set appropriate offsets for each product
     * @param {Object} all the products from success function of fetchBlock
     * @param {Object} offsetMap to store actual and expanded offsets for the product
     */
    ProductListingViewModel.prototype.expandProducts = function(pProducts, pOffsetMap) {
      var self = this;
      var expandedItems = [];
      var product, sku, skuGroups;
      var productListingTypes = this.widget.productListingTypes;
      var productTypeLevelOrder = [];
      var productLevelOrder = [];
      var listingVariantOption;
      var expandedIndex=0;
      
      if (pProducts) {
        for (var index = 0, prodLength = pProducts.length; index &lt; prodLength; index++) {
          product = pProducts[index];
          listingVariantOption = undefined;
          if (product.childSKUs.length > 0 &amp;&amp; product.productVariantOptions &amp;&amp; product.productVariantOptions.length > 0) {
            skuGroups = {};
            // If we already know the listing variant of the product type, get it from productTypeListingVariantMap, otherwise calculate and store in productTypeListingVariantMap
            if(product.type in self.productTypeListingVariantMap){
              listingVariantOption = self.productTypeListingVariantMap[product.type];
            }else{
              ko.utils.arrayForEach(product.productVariantOptions, function(productVariantOption) {
                if (productVariantOption.listingVariant === true &amp;&amp; productVariantOption.variantBasedDisplay === true) {
                  listingVariantOption =  productVariantOption;
                }
              });
              self.productTypeListingVariantMap[product.type] = listingVariantOption;
            }
            if(listingVariantOption){
              productLevelOrder = product.variantValuesOrder[listingVariantOption.optionId];
              for(var key in listingVariantOption.optionValueMap){
                productTypeLevelOrder[listingVariantOption.optionValueMap[key]] = key;
              }
              for (var lcIndex = 0, lcLength = product.childSKUs.length; lcIndex &lt; lcLength; lcIndex++) {
                sku = product.childSKUs[lcIndex];
                if (!skuGroups[sku[listingVariantOption.optionId]] || sku.productListingSku) {
                  var obj = {};
                  obj.product = pProducts[index];
                  obj.listingSku = sku;
                  skuGroups[sku[listingVariantOption.optionId]] = obj;
                }
              }
              var orderingArray = [];
              if (productLevelOrder &amp;&amp; productLevelOrder.length > 0) {
                orderingArray = productLevelOrder
              } else {
                orderingArray = productTypeLevelOrder
              }
              for (var orderingIdx = 0; orderingIdx &lt; orderingArray.length; orderingIdx++) {
                if (skuGroups[orderingArray[orderingIdx]]) {
                  expandedItems[expandedIndex] = skuGroups[orderingArray[orderingIdx]];
                  expandedItems[expandedIndex].offsetMap = pOffsetMap;
                  expandedIndex++;
                }
              }
            }
          } if (listingVariantOption == undefined ) {
            var obj = {};
            obj.product = pProducts[index];
            expandedItems[expandedIndex] = obj;
            expandedItems[expandedIndex].offsetMap = pOffsetMap;
            expandedIndex++;
          }
        }
       
      }

      return expandedItems;
    };

    /**
     * The results text.
     * Builds up a string, based on the number of products returned, and the size of the viewport.
     * @private
     * @returns {string} The results string.
     */
    ProductListingViewModel.prototype.getResultsText = function() {
      var startIndex = this.pageStartIndex();
      var resultsText;

      if (this.isLoadOnScroll()) {
        startIndex = 0;
      }

      if (ccNumber.formatNumber(this.totalNumber())) {

        if (this.totalNumber() > 0) {
          resultsText = CCi18n.t('ns.common:resources.productresultsText',
            { startIndex: ccNumber.formatNumber(startIndex + 1),
              endIndex: ccNumber.formatNumber(this.pageEndIndex()),
              totalProducts: ccNumber.formatNumber(this.totalNumber())
            });
        }
        else {
          resultsText = CCi18n.t('ns.common:resources.emptyProductresultsText');
        }
      }

      if(resultsText === 'ns.common:resources.productresultsText') {
        resultsText = '';
      }

      return resultsText;
    };

    /**
     * The title text.
     * Builds up a string to be used as a title. If a category is selected, the category
     * name is returned. Otherwise, falls back to a static resource string.
     * @private
     * @returns {string} The title.
     */
    ProductListingViewModel.prototype.getTitleText = function() {

      var retText = '';

      if (this.category()) {
        retText = this.category().displayName;
      } else {
        retText = CCi18n.t('ns.common:resources.TitleText');
      }

      return retText;
    };

    return ProductListingViewModel;
  }
);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ccKoErrorWrapper.html">ccKoErrorWrapper</a></li><li><a href="module-ccKoExtensions.html">ccKoExtensions</a></li></ul><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="CartViewModel.html">CartViewModel</a></li><li><a href="CCStoreConfiguration.html">CCStoreConfiguration</a></li><li><a href="CheckoutScheduledOrder.html">CheckoutScheduledOrder</a></li><li><a href="delegatedAdminContacts.html">delegatedAdminContacts</a></li><li><a href="DynamicProperty.html">DynamicProperty</a></li><li><a href="DynamicPropertyMetaContainer.html">DynamicPropertyMetaContainer</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="GiftCardViewModel.html">GiftCardViewModel</a></li><li><a href="GiftProductListingViewModel.html">GiftProductListingViewModel</a></li><li><a href="global.html#InfinityViewModel">InfinityViewModel</a></li><li><a href="IntegrationViewModel.html">IntegrationViewModel</a></li><li><a href="ko.bindingHandlers.background.html">background</a></li><li><a href="ko.bindingHandlers.carouselSwipe.html">carouselSwipe</a></li><li><a href="ko.bindingHandlers.ccDateTime.html">ccDateTime</a></li><li><a href="ko.bindingHandlers.ccForm.html">ccForm</a></li><li><a href="ko.bindingHandlers.ccLink.html">ccLink</a></li><li><a href="ko.bindingHandlers.ccValidation.html">ccValidation</a></li><li><a href="ko.bindingHandlers.checkbox.html">checkbox</a></li><li><a href="ko.bindingHandlers.chosen.html">chosen</a></li><li><a href="ko.bindingHandlers.contextResourcesNamespace.html">contextResourcesNamespace</a></li><li><a href="ko.bindingHandlers.currency.html">currency</a></li><li><a href="ko.bindingHandlers.datepicker.html">datepicker</a></li><li><a href="ko.bindingHandlers.datepopover.html">datepopover</a></li><li><a href="ko.bindingHandlers.draggable.html">draggable</a></li><li><a href="ko.bindingHandlers.droppable.html">droppable</a></li><li><a href="ko.bindingHandlers.fade.html">fade</a></li><li><a href="ko.bindingHandlers.hover.html">hover</a></li><li><a href="ko.bindingHandlers.image.html">image</a></li><li><a href="ko.bindingHandlers.imageSource.html">imageSource</a></li><li><a href="ko.bindingHandlers.imageZoom.html">imageZoom</a></li><li><a href="ko.bindingHandlers.localeText.html">localeText</a></li><li><a href="ko.bindingHandlers.makeAccess.html">makeAccess</a></li><li><a href="ko.bindingHandlers.modal.html">modal</a></li><li><a href="ko.bindingHandlers.modalTabbingContraint.html">modalTabbingContraint</a></li><li><a href="ko.bindingHandlers.onRender.html">onRender</a></li><li><a href="ko.bindingHandlers.popeditor.html">popeditor</a></li><li><a href="ko.bindingHandlers.popover.html">popover</a></li><li><a href="ko.bindingHandlers.productImageSource.html">productImageSource</a></li><li><a href="ko.bindingHandlers.productVariantImageSource.html">productVariantImageSource</a></li><li><a href="ko.bindingHandlers.propertyEditor.html">propertyEditor</a></li><li><a href="ko.bindingHandlers.radio.html">radio</a></li><li><a href="ko.bindingHandlers.richTextEditor.html">richTextEditor</a></li><li><a href="ko.bindingHandlers.scrollAffix.html">scrollAffix</a></li><li><a href="ko.bindingHandlers.select2.html">select2</a></li><li><a href="ko.bindingHandlers.select2Tags.html">select2Tags</a></li><li><a href="ko.bindingHandlers.selectable.html">selectable</a></li><li><a href="ko.bindingHandlers.slide.html">slide</a></li><li><a href="ko.bindingHandlers.slider.html">slider</a></li><li><a href="ko.bindingHandlers.spectrum.html">spectrum</a></li><li><a href="ko.bindingHandlers.textCheck.html">textCheck</a></li><li><a href="ko.bindingHandlers.timepicker.html">timepicker</a></li><li><a href="ko.bindingHandlers.triggerMessage.html">triggerMessage</a></li><li><a href="ko.bindingHandlers.validatableTarget.html">validatableTarget</a></li><li><a href="ko.bindingHandlers.validatableValue.html">validatableValue</a></li><li><a href="ko.bindingHandlers.widgetLocaleText.html">widgetLocaleText</a></li><li><a href="koValidation.alphaNumeric.html">alphaNumeric</a></li><li><a href="koValidation.alphaNumericNoSpaces.html">alphaNumericNoSpaces</a></li><li><a href="koValidation.alphaNumericNoSpacesNoDashesWithSeperators.html">alphaNumericNoSpacesNoDashesWithSeperators</a></li><li><a href="koValidation.alphaNumericNoSpacesWithSeperators.html">alphaNumericNoSpacesWithSeperators</a></li><li><a href="koValidation.alphaNumericWithSeperators.html">alphaNumericWithSeperators</a></li><li><a href="koValidation.bool.html">bool</a></li><li><a href="koValidation.creditcard.html">creditcard</a></li><li><a href="koValidation.cvv.html">cvv</a></li><li><a href="koValidation.endmonth.html">endmonth</a></li><li><a href="koValidation.endyear.html">endyear</a></li><li><a href="koValidation.importFileName.html">importFileName</a></li><li><a href="koValidation.laterDate.html">laterDate</a></li><li><a href="koValidation.match.html">match</a></li><li><a href="koValidation.mediaZipFileName.html">mediaZipFileName</a></li><li><a href="koValidation.number.html">number</a></li><li><a href="koValidation.observablePattern.html">observablePattern</a></li><li><a href="koValidation.password.html">password</a></li><li><a href="koValidation.price.html">price</a></li><li><a href="koValidation.propertyIdAlreadyInUse.html">propertyIdAlreadyInUse</a></li><li><a href="koValidation.propertyNameAlreadyInUse.html">propertyNameAlreadyInUse</a></li><li><a href="koValidation.restrictSlashCharacters.html">restrictSlashCharacters</a></li><li><a href="koValidation.startmonth.html">startmonth</a></li><li><a href="koValidation.startyear.html">startyear</a></li><li><a href="koValidation.uniqueTrimmed.html">uniqueTrimmed</a></li><li><a href="koValidation.uniqueTrimmedCaseInsensitive.html">uniqueTrimmedCaseInsensitive</a></li><li><a href="koValidation.url.html">url</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.addTemplate.html">addTemplate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.agentBar.html">agentBar</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDate.html">ccDate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccNumber.html">ccNumber</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccResizeImage.html">ccResizeImage</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.disabled.html">disabled</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.element.html">element</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.embeddedAssistance.html">embeddedAssistance</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.fireChange.html">fireChange</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.inTabFlow.html">inTabFlow</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.noIndexMeta.html">noIndexMeta</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.previewBar.html">previewBar</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.setContextVariable.html">setContextVariable</a></li><li><a href="multiCartViewModel.html">multiCartViewModel</a></li><li><a href="NavStateViewModel.html">NavStateViewModel</a></li><li><a href="OrderDetailsViewModel.html">OrderDetailsViewModel</a></li><li><a href="OrderHistoryViewModel.html">OrderHistoryViewModel</a></li><li><a href="OrdersPendingApprovalViewModel.html">OrdersPendingApprovalViewModel</a></li><li><a href="OrderViewModel.html">OrderViewModel</a></li><li><a href="Organization.html">Organization</a></li><li><a href="ParentOrganisation.html">ParentOrganisation</a></li><li><a href="ProductListingSearchViewModel.html">ProductListingSearchViewModel</a></li><li><a href="ProductListingViewModel.html">ProductListingViewModel</a></li><li><a href="ProductTypes.html">ProductTypes</a></li><li><a href="ProductViewModel.html">ProductViewModel</a></li><li><a href="PromotionUpsellContainer.html">PromotionUpsellContainer</a></li><li><a href="PubSub.topicNames.html">topicNames</a></li><li><a href="PurchaseListListingViewModel.html">PurchaseListListingViewModel</a></li><li><a href="PurchaseListViewModel.html">PurchaseListViewModel</a></li><li><a href="RegistrationRequestSearchViewModel.html">RegistrationRequestSearchViewModel</a></li><li><a href="resetCVV.html">resetCVV</a></li><li><a href="resetGiftCardPin.html">resetGiftCardPin</a></li><li><a href="resetPaymentDetails.html">resetPaymentDetails</a></li><li><a href="ReturnItem.html">ReturnItem</a></li><li><a href="ReturnViewModel.html">ReturnViewModel</a></li><li><a href="scheduledOrderList.html">scheduledOrderList</a></li><li><a href="SearchRestClient.html">SearchRestClient</a></li><li><a href="ServerData.html">ServerData</a></li><li><a href="UserViewModel.html">UserViewModel</a></li><li><a href="WidgetViewModel.html">WidgetViewModel</a></li><li><a href="WishlistContentViewModel.html">WishlistContentViewModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.extenders.html">extenders</a></li><li><a href="koValidation.html">koValidation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addItemToPurchaseList">addItemToPurchaseList</a></li><li><a href="global.html#callWidgetMethodIfApplicable">callWidgetMethodIfApplicable</a></li><li><a href="global.html#CartViewModel#deleteParticularIncompleteOrdersDeletesanincompleteorderbyorderId">CartViewModel#deleteParticularIncompleteOrdersDeletes an incomplete order by orderId</a></li><li><a href="global.html#CCEETagProcessor">CCEETagProcessor</a></li><li><a href="global.html#doesSiteExist">doesSiteExist</a></li><li><a href="global.html#fetchSkuDetailsListError">fetchSkuDetailsListError</a></li><li><a href="global.html#fetchSkuDetailsListSuccess">fetchSkuDetailsListSuccess</a></li><li><a href="global.html#formatSiteText">formatSiteText</a></li><li><a href="global.html#handleInitiateEditSuccess">handleInitiateEditSuccess</a></li><li><a href="global.html#isModified">isModified</a></li><li><a href="global.html#isValidDeterminewhetherornotthepaymentdetailsobjectisvalidbasedonthevalidityofitscomponentparts.Thiswillnotcauseerrormessagestobedisplayedforanyobservablevaluesthatareunchangedandhaveneverreceivedfocusontherelatedformfield(s).">isValidDetermine whether or not the payment details object is validbased on the validity of its component parts. This will notcause error messages to be displayed for any observable valuesthat are unchanged and have never received focus on the related form field(s).</a></li><li><a href="global.html#justFocused">justFocused</a></li><li><a href="global.html#mapProperties">mapProperties</a></li><li><a href="global.html#MENU_CLOSE_TIMEOUT">MENU_CLOSE_TIMEOUT</a></li><li><a href="global.html#populateData">populateData</a></li><li><a href="global.html#populateProductData">populateProductData</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetModified">resetModified</a></li><li><a href="global.html#Resetsstylingforthelazilyloadedimage">Resets styling for the lazily loaded image</a></li><li><a href="global.html#Setsupstylingfortheimagetobelazilyloaded">Sets up styling for the image to be lazily loaded</a></li><li><a href="global.html#ShopperContextViewModel">ShopperContextViewModel</a></li><li><a href="global.html#thelistofpropertiestoignorewhilecopyingdynamicpropertiestoaddressobject">the list of properties to ignore while copying dynamic properties to address object</a></li><li><a href="global.html#validatePaymentDetailsForceallrelevantmemberobservablestoperformtheirvalidationnow&displaytheerrors(ifany)">validatePaymentDetailsForce all relevant member observables to perform theirvalidation now & display the errors (if any)</a></li><li><a href="global.html#WidgetQueue">WidgetQueue</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Wed Feb 26 2020 18:22:22 GMT+0530 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
