<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Dynamo/Client/Store/web/store.war/shared/js/viewModels/shipping-group-relationship.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: Dynamo/Client/Store/web/store.war/shared/js/viewModels/shipping-group-relationship.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * @fileoverview Defines a ShippingGroupRelationship item which represents an association between a cart item and a shipping group.
 */

/*global define */
define(function (require) {
    "use strict";
    var ko = require('knockout');
    var ccConstants = require('ccConstants');
    var CCi18n = require('CCi18n');
    var CCStoreConfiguration = require('ccStoreConfiguration');
    var ccRestClient = require('ccRestClient');
    var CCDate = require('ccDate');
    var Address = require('viewModels/address');

    /**
     * &lt;p>
     *  The view model class that represents an association between a cart item and a shipping group. Strictly
     *  speaking, ShippingGroupRelationships associates a specified quantity of the cart item with a shipping address
     *  and shipping method (not shipping group), however the shipping groups array is directly generated from the 
     *  ShippingGroupRelationships instances (see the createShippingGroups method). When the user selects a shipping 
     *  address and shipping method for a given cart item, it is this class that captures those selections.
     * &lt;/p>
     *
     * @private
     * @class
     * @name ShippingGroupRelationship
     * @param {CartItem} cartItem - The associated cart item.
     * @param {Number} quantity - The initial quantity of cart item to be associated to the shipping group.
     * @property {ko.observable&lt;Number>} quantity - The quantity of cart item to be associated to the shipping group.
     * @property {ko.observable} selectedStore - The store selected for picking up the item.
     * @property {ko.observable&lt;Address>} shippingAddress - The address to which this quantity of cart item should be 
     *    shipped.
     * @property {ko.observable&lt;ShippingMethodItemViewModel>} shippingMethod - The method by which this quantity of
     *    cart item should be shipped.
     */
    function ShippingGroupRelationship (cartItem, quantity) {
      var self = this;
      // Default args.
      quantity = quantity || 0;

      // Properties.
      self.catRefId = cartItem.catRefId;
      self.productId = cartItem.productId;
      self.childItems = cartItem.childItems;
      self.quantity = ko.observable(quantity);
      self.updatableQuantity = ko.observable(quantity);
      self.stockStatus = ko.observable(true);
      if(cartItem.availabilityDate &amp;&amp; ko.isObservable(cartItem.availabilityDate) ) {
        self.availabilityDate = ko.observable(cartItem.availabilityDate());
      } else if (cartItem.availabilityDate) {
        self.availabilityDate = ko.observable(cartItem.availabilityDate);
      } else {
        self.availabilityDate = ko.observable();
      }
      self.stockState = ko.observable();
      if(cartItem.stockState) {
        if(ko.isObservable(cartItem.stockState) &amp;&amp; '' !== cartItem.stockState()) {
    	  self.stockState(cartItem.stockState());
        } else if(!ko.isObservable(cartItem.stockState) &amp;&amp; '' !== cartItem.stockState) {
          self.stockState(cartItem.stockState);
        }
      }
      self.orderableQuantityMessage = ko.observable();
      self.shippingOptions = ko.observableArray();
      self.shippingAddress = ko.observable();
      self.shippingMethod = ko.observable();
      self.isPickupInStore = ko.observable();
      self.selectedStore = ko.observable();
      self.shippingGroupId = ko.pureComputed(function() {
        var id = self.productId + self.catRefId + self.quantity();
        if(self.shippingAddress &amp;&amp; null != self.shippingAddress()) {
          id = id + self.shippingAddress();
        }
        if(self.shippingMethod &amp;&amp; null != self.shippingMethod()) {
          id = id + self.shippingMethod();
        }
        return (self.selectedStore &amp;&amp; null != self.selectedStore()) ? id + self.selectedStore().locationId : id;

      }, self).extend({deferred: true});
      self.detailedItemPriceInfo = cartItem.detailedItemPriceInfo;
      if(cartItem.price &amp;&amp; ko.isObservable(cartItem.price)) {
        self.price = ko.observable(cartItem.price());
      } else {
        self.price = ko.observable(cartItem.price);
      }
      self.unitPrice = ko.observable(cartItem.unitPrice);
      self.availablePickupDate = ko.observable();
      self.preferredPickupDate = ko.observable();
      if (cartItem.availablePickupDate) {
        self.availablePickupDate = ko.observable(cartItem.availablePickupDate);
      }
      if (cartItem.preferredPickupDate) {
        self.preferredPickupDate = ko.observable(cartItem.preferredPickupDate);
      }
      self.firstName = ko.observable();
      self.middleName = ko.observable();
      self.lastName = ko.observable();
      self.phoneNumber = ko.observable();

      self.updatableQuantity.extend({
        required: {params: true, message: CCi18n.t('ns.common:resources.quantityRequireMsg')},
        digit: {params: true, message: CCi18n.t('ns.common:resources.quantityNumericMsg')},
        trigger: {value: '0', message: CCi18n.t('ns.common:resources.removeItemMsg')}
      });

      self.firstName.extend({
        maxLength: {params: CCStoreConfiguration.ADDRESS_FIRSTNAME_MAXIMUM_LENGTH ? CCStoreConfiguration.ADDRESS_FIRSTNAME_MAXIMUM_LENGTH : ccConstants.CYBERSOURCE_FIRSTNAME_MAXIMUM_LENGTH,
                    message: CCi18n.t('ns.common:resources.maxlengthValidationMsg',{fieldName: CCi18n.t('ns.common:resources.firstNameText'),maxLength:CCStoreConfiguration.ADDRESS_FIRSTNAME_MAXIMUM_LENGTH ? CCStoreConfiguration.ADDRESS_FIRSTNAME_MAXIMUM_LENGTH : ccConstants.CYBERSOURCE_FIRSTNAME_MAXIMUM_LENGTH}) }});

      self.lastName.extend({ maxLength: {params: CCStoreConfiguration.ADDRESS_LASTNAME_MAXIMUM_LENGTH ? CCStoreConfiguration.ADDRESS_LASTNAME_MAXIMUM_LENGTH : ccConstants.CYBERSOURCE_LASTNAME_MAXIMUM_LENGTH,
                    message: CCi18n.t('ns.common:resources.maxlengthValidationMsg',{fieldName: CCi18n.t('ns.common:resources.lastNameText'),maxLength:CCStoreConfiguration.ADDRESS_LASTNAME_MAXIMUM_LENGTH ? CCStoreConfiguration.ADDRESS_LASTNAME_MAXIMUM_LENGTH : ccConstants.CYBERSOURCE_LASTNAME_MAXIMUM_LENGTH}) }});

      // Very basic checking for phone numbers as there are so many different valid patterns
      self.phoneNumber.extend({ pattern: { params: "^[0-9()+ -]+$", message: CCi18n.t('ns.common:resources.phoneNumberInvalid')},
                                maxLength: { params:  ccConstants.CYBERSOURCE_PHONE_NUMBER_MAXIMUM_LENGTH,message: CCi18n.t('ns.common:resources.maxlengthValidationMsg',{fieldName: CCi18n.t('ns.common:resources.phoneNumberText'),maxLength: ccConstants.CYBERSOURCE_PHONE_NUMBER_MAXIMUM_LENGTH}) } });


      /**
       * Add validation functions to updatable quantity field to ensure it lies between the maximum orderable
       * quantity and greater than zero, and there is available stock.
       *
       * @private
       * @function
       * @name #addLimitsValidation
       * @param {object} cartItem associated with shipping group.
       * @param {object} shGrpInvDetails Inve.
       * @param {boolean} isPreOrderBackOrderEnabled tells if preorder / backorder is enabled.
       */
      self.addLimitsValidation = function (cartItem, shGrpInvDetails, isPreOrderBackOrderEnabled, isOrderAmendment, validOrderableQuantity, orderedQuantityMap) {
        var orderLimit = self.quantity();
        var skuInvDetails = null;
        var actualOrderableQuantity;
        for (var inventoryIndex = 0; inventoryIndex &lt; shGrpInvDetails.length; inventoryIndex++) {
          if (self.productId === shGrpInvDetails[inventoryIndex].productId
              &amp;&amp; (self.catRefId === shGrpInvDetails[inventoryIndex].catRefId)) {
            skuInvDetails = shGrpInvDetails[inventoryIndex];
          }
        }
        if(null === skuInvDetails) {
          return; // no inventory details found for current product / sku.
        }
        if (cartItem.productData() &amp;&amp; cartItem.productData().notForIndividualSale &amp;&amp; cartItem.isThisGWPCommerceItemAndValid()) {
          if (skuInvDetails) {
            skuInvDetails.orderLimit = self.quantity();
          }
        }
        var stockStatus = skuInvDetails.stockStatus === 'IN_STOCK'
            || skuInvDetails.stockStatus === 'PREORDERABLE'
            || skuInvDetails.stockStatus === 'BACKORDERABLE';
        self.stockStatus(stockStatus);
        if(skuInvDetails){
          orderLimit = skuInvDetails.orderLimit
          self.availabilityDate(skuInvDetails.availabilityDate);
        }
        self.updatableQuantity.rules.remove(function (item) {return item.rule == "max";});
        self.updatableQuantity.rules.remove(function (item) {return item.rule == "maxItemQuantity";});

        if(isOrderAmendment){
          actualOrderableQuantity = validOrderableQuantity ;
        }else {
          actualOrderableQuantity = skuInvDetails.orderableQuantity;
        }
        if (actualOrderableQuantity !== null
            &amp;&amp; !isNaN(actualOrderableQuantity) &amp;&amp; actualOrderableQuantity > 0 ) {
          var insufficientStockMsg = CCi18n.t('ns.common:resources.insufficientStockMsg', {
            stockLimit: orderLimit &amp;&amp; orderLimit&lt;actualOrderableQuantity ?orderLimit : actualOrderableQuantity
          });

          self.updatableQuantity.extend({
            maxItemQuantity:{params: {orderableQuantity: actualOrderableQuantity,
              totalQuantity : self.getItemQuantityInCart, orderLimit:orderLimit}, message: insufficientStockMsg}
          });
        } else {
          var outOfStockMsg = CCi18n.t('ns.common:resources.outOfStockMsg');

          self.updatableQuantity.extend({
            max: {params: 0, message: outOfStockMsg}
          });
        }

        var partialMsg = "";
        if(ccRestClient.profileType === ccConstants.PROFILE_TYPE_AGENT) {
            partialMsg = self.getOrderableQuantityMessageForAgent(cartItem, skuInvDetails,isPreOrderBackOrderEnabled,isOrderAmendment,orderedQuantityMap)
        }else{        
        	if(isPreOrderBackOrderEnabled &amp;&amp; skuInvDetails &amp;&amp; null !== skuInvDetails
                    &amp;&amp; (skuInvDetails.inStockQuantity > 0 &amp;&amp; self.updatableQuantity() > skuInvDetails.inStockQuantity)) {
                  if (skuInvDetails.backOrderableQuantity > 0) {
                    partialMsg = CCi18n.t('ns.common:resources.partialBackOrderMsg', {stockLimit: skuInvDetails.inStockQuantity});
                  }
                  else if(skuInvDetails.preOrderableQuantity > 0) {
                    partialMsg = CCi18n.t('ns.common:resources.partialPreOrderMsg', {stockLimit: skuInvDetails.inStockQuantity});
                  }
        	}
        	if(shGrpInvDetails){
              self.stockState(skuInvDetails.stockStatus);
            }
        }
        self.orderableQuantityMessage(partialMsg);

        //added this to trigger the validations on load of page.
        self.updatableQuantity.isModified(true);
      };

      /*
      *This method calculates the stock status during Agent Create/Edit order scenario
      *and generates messages wrt to back/pre order, full back/pre order and child items.
      *
      * @private
      * @function
      * @name CartItem#getOrderableQuantityMessageForAgent.
      * @pItem {Object} cart data of the specific item.
      * @pStockData {Object} stockData of the item returned form stockStatus call.
      * @isPreOrderBackOrderEnabled {boolean} boolean value if back/Pre order configuration is enabled.
      * @isOrderAmendment {boolean} value to determine if the flow is from edit order(Agent Flow).
      * @orderedQuantityMap {map} map which holds the specific value of backorder , preorder and in_stock quantities when order was plcaed.
      * @quantityMultiplier {integer} holds the quantity of main item which has child item.
      */
      self.getOrderableQuantityMessageForAgent = function(pItem, pStockData, isPreOrderBackOrderEnabled, isOrderAmendment, orderedQuantityMap, quantityMultiplier) {
        var self = this;
        var statusMsg = "";
        var itemStockStatus = "IN_STOCK";


            var inStockQuantity = pStockData.inStockQuantity;
            var backorderQuantity = pStockData.backOrderableQuantity;
            var preorderQuantity = pStockData.preOrderableQuantity;
            var updatableQuantity;
            if(quantityMultiplier){
              updatableQuantity = pItem.quantity * quantityMultiplier;
            }else{
              updatableQuantity = pItem.updatableQuantity();
            }
            var quantity = updatableQuantity &lt; pStockData.orderableQuantity ? updatableQuantity : pStockData.orderableQuantity;

            var key = pItem.productId + ":" + pItem.catRefId;
            if(isOrderAmendment &amp;&amp; orderedQuantityMap[key]){
              backorderQuantity = backorderQuantity + orderedQuantityMap[key].backOrderQuantity;
              preorderQuantity = preorderQuantity + orderedQuantityMap[key].preOrderQuantity;
              inStockQuantity = inStockQuantity + orderedQuantityMap[key].inStockQuantity;

              var nonInStockQuantity = quantity - inStockQuantity;
              if(nonInStockQuantity > 0){
                if(nonInStockQuantity - backorderQuantity > 0){
                  statusMsg = CCi18n.t('ns.common:resources.AgentPreorderableText', {stockLimit: CCi18n.t('ns.common:resources.asteriskSymbol')});
                  itemStockStatus = ccConstants.PREORDERABLE;
                }else{
                  statusMsg = CCi18n.t('ns.common:resources.AgentBackorderableText', {stockLimit: CCi18n.t('ns.common:resources.asteriskSymbol')});
                  itemStockStatus = ccConstants.BACKORDERABLE;
                }
              }else{
                itemStockStatus = "IN_STOCK";
              }

            }else{
              if (pStockData.stockStatus &amp;&amp; (quantity - inStockQuantity) > 0) {
                if (backorderQuantity > 0) {
                  statusMsg = CCi18n.t('ns.common:resources.AgentBackorderableText', {stockLimit: CCi18n.t('ns.common:resources.asteriskSymbol')});
                  itemStockStatus = ccConstants.BACKORDERABLE;
                } else if (preorderQuantity > 0) {
                  statusMsg = CCi18n.t('ns.common:resources.AgentPreorderableText', {stockLimit: CCi18n.t('ns.common:resources.asteriskSymbol')});
                  itemStockStatus = ccConstants.PREORDERABLE;
                }
              } else {
                if (pStockData.stockStatus &amp;&amp; pStockData.stockStatus === "BACKORDERABLE") {
                  statusMsg = CCi18n.t('ns.common:resources.AgentBackorderableText', {stockLimit: CCi18n.t('ns.common:resources.asteriskSymbol')});
                } else if (pStockData.stockStatus &amp;&amp; pStockData.stockStatus === "PREORDERABLE") {
                  statusMsg = CCi18n.t('ns.common:resources.AgentPreorderableText', {stockLimit: CCi18n.t('ns.common:resources.asteriskSymbol')});
                }
              }
            }
            self.stockState(itemStockStatus);
            self.availabilityDate(pStockData.availabilityDate ? CCDate.dateTimeFormatter(pStockData.availabilityDate, null, "medium") : '');

        return statusMsg.trim();
      };

      /**
       * Add checks and validation functions to updatable quantity field of a configured
       * item to make sure the quantity is within the values that makes sure that the
       * main item as well as the child items are in stock.
       *
       * @private
       * @function
       * @name #addConfigurableStockValidation
       * @param {Object} stockData the stock related data of all the skus present
       *                 in the cart.
       * @param {boolean} isPreOrderBackOrderEnabled tells if preorder / backorder is enabled.
       */
      self.addConfigurableStockValidation = function (stockData, isPreOrderBackOrderEnabled, isOrderAmendment, validOrderQuantityMap, orderedQuantityMap) {
        var maxOrderableQuantity = 0;
        var orderLimit = 0;
        var stockStatus = false;
        var availabilityDate = null;
        var stockState = null;
        var validOrderableQuantity
        // Main item
        for (var i = 0; i &lt; stockData.length; i++) {
          if (self.productId === stockData[i].productId
              &amp;&amp; self.catRefId === stockData[i].catRefId) {

              if(isOrderAmendment  &amp;&amp; validOrderQuantityMap[stockData[i].productId + ":" + stockData[i].catRefId]){
                validOrderableQuantity = validOrderQuantityMap[stockData[i].productId + ":" + stockData[i].catRefId];
              }else {
                validOrderableQuantity = stockData[i].orderableQuantity;
              }
            if (stockData[i].stockStatus === 'IN_STOCK'
                || ( isPreOrderBackOrderEnabled &amp;&amp; ( stockData[i].stockStatus === 'BACKORDERABLE' || stockData[i].stockStatus === 'PREORDERABLE')) 
                || ( ccRestClient.profileType === ccConstants.PROFILE_TYPE_AGENT &amp;&amp; validOrderableQuantity > 0) )  {

              if ( validOrderableQuantity !== null
                  &amp;&amp; !isNaN(validOrderableQuantity) &amp;&amp; validOrderableQuantity > 0 ) {
                var partialMsg = "";
                stockStatus = true;
                availabilityDate = stockData[i].availabilityDate;
                stockState = stockData[i].stockStatus;
                maxOrderableQuantity = validOrderableQuantity;
                orderLimit = stockData[i].orderLimit;

                if(ccRestClient.profileType === ccConstants.PROFILE_TYPE_AGENT){
                    partialMsg = self.getOrderableQuantityMessageForAgent(self, stockData[i],isPreOrderBackOrderEnabled,isOrderAmendment,orderedQuantityMap)
                }else{
                	if (isPreOrderBackOrderEnabled
                            &amp;&amp; stockData[i].inStockQuantity > 0 &amp;&amp; self.updatableQuantity() > stockData[i].inStockQuantity) {
                          if (stockData[i].backOrderableQuantity > 0) {
                            partialMsg = CCi18n.t('ns.common:resources.partialBackOrderMsg', {
                              stockLimit: stockData[i].inStockQuantity
                            });
                          } else if (stockData[i].preOrderableQuantity > 0) {
                            partialMsg = CCi18n.t('ns.common:resources.partialPreOrderMsg', {
                              stockLimit: stockData[i].inStockQuantity
                            });
                          }
                     }	
                }
              }
              else {
                stockStatus = false;
              }
            }
            else {
              stockStatus = false;
            }
            break;
          }
        }

        // Now add a check for all the child items and the quantity. If one of the child
        // items can be added less than the maxOrderableQuantity, then update the
        // maxOrderableQuantity with that value.
        if (self.childItems &amp;&amp; stockStatus ) {
          for (var i = 0; i &lt; self.childItems.length; i++) {
            var productId = self.childItems[i].productId;
            var catRefId = self.childItems[i].catRefId;
            var quantity = ko.utils.unwrapObservable(self.childItems[i].quantity);
            var validOrderableQuantityOfChild = 0;           


            for (var j = 0; j &lt; stockData.length; j++) {
              if (productId === stockData[j].productId &amp;&amp; catRefId === stockData[j].catRefId) {
            	  
            	if(isOrderAmendment &amp;&amp; validOrderQuantityMap[productId + ":" + catRefId]){
                   validOrderableQuantityOfChild = validOrderQuantityMap[productId + ":" + catRefId];
                }else{
                    validOrderableQuantityOfChild = stockData[j].orderableQuantity;
                }            	  
                if (stockData[j].stockStatus === 'IN_STOCK'
                    || ( isPreOrderBackOrderEnabled &amp;&amp; ( stockData[j].stockStatus === 'BACKORDERABLE' || stockData[j].stockStatus === 'PREORDERABLE')) 
                    || ( ccRestClient.profileType === ccConstants.PROFILE_TYPE_AGENT &amp;&amp; validOrderableQuantityOfChild > 0 ) ) {

                  if (validOrderableQuantityOfChild !== null &amp;&amp; !isNaN(validOrderableQuantityOfChild) &amp;&amp; validOrderableQuantityOfChild > 0) {
                    // Get the current quantity and floor the max orderable
                    // accordingly.
                    var orderableQuantity = Math.floor(validOrderableQuantityOfChild / quantity);
                    maxOrderableQuantity = (maxOrderableQuantity > orderableQuantity) ? orderableQuantity : maxOrderableQuantity;
                    orderLimit = (orderLimit>stockData[j].orderLimit)?stockData[j].orderLimit:orderLimit;
                    stockStatus = true;
                    if(ccRestClient.profileType === ccConstants.PROFILE_TYPE_AGENT){
                      var quantityMultiplier = self.updatableQuantity();
                      partialMsg = self.getOrderableQuantityMessageForAgent(self.childItems[i], stockData[j],isPreOrderBackOrderEnabled,isOrderAmendment,orderedQuantityMap, quantityMultiplier)
                    }
                  } else {
                    stockStatus = false;
                  }
                } else {
                  stockStatus = false;
                }
                break;
              }
            }
            if (!stockStatus) {
              // If one of the product is out of stock, break it out.
              break;
            }
          }
        }

        
        if(ccRestClient.profileType !== ccConstants.PROFILE_TYPE_AGENT){
          self.availabilityDate(availabilityDate);
          self.stockState(stockState);
        }
        self.stockStatus(stockStatus);

        self.orderableQuantityMessage(partialMsg);
        self.updatableQuantity.rules.remove(function (item) {return item.rule == "max";});
        self.updatableQuantity.rules.remove(function (item) {return item.rule == "maxItemQuantity";});

        if ( stockStatus &amp;&amp; maxOrderableQuantity > 0) {
          var insufficientStockMsg = CCi18n.t('ns.common:resources.insufficientStockMsg', {
            stockLimit: (maxOrderableQuantity>orderLimit)?orderLimit:maxOrderableQuantity
          });

          self.updatableQuantity.extend({
            maxItemQuantity:{params: {orderableQuantity:maxOrderableQuantity,
              totalQuantity:self.getItemQuantityInCart, orderLimit:orderLimit, childItems:self.childItems}, message: insufficientStockMsg}
          });
        }
        else {
          var outOfStockMsg = CCi18n.t('ns.common:resources.configurableProductOutOfStockMsg');

          self.updatableQuantity.extend({
            max: {params: 0, message: outOfStockMsg}
          });
        }

        self.updatableQuantity.isModified(true);
      };
    }

    /**
     * Updates the properties of shipping group after a price call.
     *
     * @function
     * @name ShippingGroupRelationship#update
     * @param {Object} data is the object from where it needs to be updated
     * @param {boolean} isMerge tells if update should happen while merging items or not.
     */
    ShippingGroupRelationship.prototype.update = function (data, isMerge) {
      var quantityToUpdate = data.quantity();
      if (isMerge) {
        quantityToUpdate += this.quantity();
        this.updatableQuantity(quantityToUpdate);
      }
      this.quantity(quantityToUpdate);
      this.price(data.price());
      this.unitPrice(data.unitPrice());
      this.detailedItemPriceInfo = data.detailedItemPriceInfo;
      //For non-refresh cases the shipping address is an js object so shippingAddress().isValid()
      //will throw console error. So we are checking whether postal code is observable or not, as
      //postal code is a mandatory property of an address and it is mandatory from ui also.
      if( this.shippingAddress() &amp;&amp;
          this.shippingAddress().postalCode !== null &amp;&amp;
          this.shippingAddress().postalCode !== undefined &amp;&amp;
          !ko.isObservable(this.shippingAddress().postalCode)){
        var shippingAddress = this.createAddress(this.shippingAddress());
        if (shippingAddress &amp;&amp; shippingAddress.isValid &amp;&amp;
            shippingAddress.isValid() &amp;&amp; data.shippingAddress() &amp;&amp;
            data.shippingAddress().isValid &amp;&amp; data.shippingAddress().isValid()) {
              this.shippingAddress().country = data.shippingAddress().country();
              this.shippingAddress().state = data.shippingAddress().state();
        }
      }else if (this.shippingAddress() &amp;&amp; this.shippingAddress().isValid &amp;&amp;
          this.shippingAddress().isValid() &amp;&amp; data.shippingAddress() &amp;&amp;
          data.shippingAddress().isValid &amp;&amp; data.shippingAddress().isValid()) {
        this.shippingAddress().country(data.shippingAddress().country());
        this.shippingAddress().state(data.shippingAddress().state());
      }
    }

    ShippingGroupRelationship.prototype.populateUserDetails = function (user) {
      if (user &amp;&amp; user.loggedIn()) {
        if (!this.firstName())
          this.firstName(user.firstName());
        if (!this.lastName())
          this.lastName(user.lastName());
        if (!this.phoneNumber() &amp;&amp; user.contactShippingAddress) {
          this.phoneNumber(user.contactShippingAddress.phoneNumber);
        }
      }
    }
    /**
     * generated a hashcode of shipping group relationship.
     *
     * @function
     * @name ShippingGroupRelationship#hashCode
     * @return returns hashcode.
     */
    ShippingGroupRelationship.prototype.hashCode = function (commerceItemId) {
      var hash = 0, i, chr;
      var string = this.productId + this.catRefId;
      if(commerceItemId &amp;&amp; null !== commerceItemId &amp;&amp; '' !== commerceItemId) {
    	string += commerceItemId;
      }
      if (this.isPickupInStore() &amp;&amp; this.selectedStore() &amp;&amp; this.selectedStore().store) {
        string += this.selectedStore().store.locationId;
        if (this.availablePickupDate()) {
          string += this.availablePickupDate();
        }
      } else if (this.shippingAddress() &amp;&amp; this.shippingMethod()) {
        //For non-refresh cases the shipping address is an js object so shippingAddress().isValid()
        //will throw console error. So we are checking whether postal code is observable or not, as
        //postal code is a mandatory property of an address and it is mandatory from ui also.
        if(this.shippingAddress().postalCode !== null &amp;&amp;
           this.shippingAddress().postalCode !== undefined &amp;&amp;
           !ko.isObservable(this.shippingAddress().postalCode)){
          var shippingAddress = this.createAddress(this.shippingAddress());
          if(shippingAddress.isValid &amp;&amp; shippingAddress.isValid()){
            string += shippingAddress.firstName() + shippingAddress.lastName() + shippingAddress.address1()
                   + shippingAddress.city() + shippingAddress.selectedState() + shippingAddress.selectedCountry()
                   + shippingAddress.postalCode();
          }
        }else if(this.shippingAddress().isValid &amp;&amp; this.shippingAddress().isValid()) {
          string += this.shippingAddress().firstName() + this.shippingAddress().lastName() + this.shippingAddress().address1()
              + this.shippingAddress().city() + this.shippingAddress().selectedState() + this.shippingAddress().selectedCountry()
              + this.shippingAddress().postalCode();
        }
        string += this.shippingMethod().value || this.shippingMethod().id || this.shippingMethod().repositoryId;
      }
      if (string.length === 0) {
        return hash;
      }
      for (i = 0; i &lt; string.length; i++) {
        chr   = string.charCodeAt(i);
        hash  = ((hash &lt;&lt; 5) - hash) + chr;
        hash |= 0; // Convert to 32bit integer
      }
      return hash;
    }

    /**
    * Create an object of Address from javascript object.
    *
    */
    ShippingGroupRelationship.prototype.createAddress = function(data){
      var translateHelper =  {
        translate: function(key, options) {
          return CCi18n.t('ns.common:resources.' + key, options);
        }
      };
      var shippingAddress = new Address('split-shipping-address', '', translateHelper, '', '');
      shippingAddress.copyFrom(data, []);
      return shippingAddress;
    }

    /**
     * &lt;p>
     *   Generate a unique string key for this instance (see ShippingGroupRelationship#asMap method).
     * &lt;/p>
     *
     * @private
     * @function
     * @name ShippingGroupRelationship#generateKey
     * @return {String} a unique string key for this instance.
     */
    ShippingGroupRelationship.prototype.generateKey = function () {
      var shippingAddress = this.shippingAddress();
      var shippingMethod = this.shippingMethod();
      var selectedStore = this.selectedStore();
      var key = '';

      if (this.isPickupInStore()) {
        key += selectedStore.locationId;
        if(this.availablePickupDate &amp;&amp; null !== this.availablePickupDate
            &amp;&amp; ko.isObservable(this.availablePickupDate) &amp;&amp; this.availablePickupDate()) {
          key+=this.availablePickupDate();
        }
        return key;
      }
      if (shippingAddress) {
     // Checking if toJSON() is available in shippingAddress before calling it, to map the address object
     // else use the old way of mapping.
        var addressJson;
        if (shippingAddress.hasOwnProperty('toJSON')) {
          addressJson = shippingAddress.toJSON();
        } else {
          var mapping = {'ignore':['invalidTracker']};
          addressJson = ko.mapping.toJSON(shippingAddress, mapping);
        }
        var email = addressJson.email;
        delete addressJson.email;
        addressJson.email = email; // making sure that we append email at the last
        key += JSON.stringify(addressJson);
      }
      if (shippingMethod) {
    	if(shippingMethod.repositoryId) {
    		key += shippingMethod.repositoryId;
    	}
    	if(shippingMethod.value) {
    		key += shippingMethod.value;
    	}
        
      }

      return key;
    };

    /**
     * &lt;p>
     *   Return a map representation of the ShippingGroupRelationship instance, where a string key (from 
     *   ShippingGroupRelationship#generateKey) maps to this instance. This method is used internally by 
     *   CartViewModel#createShippingGroups in order to map shipping group relationships to shipping groups.
     * &lt;/p>
     *
     * @private
     * @function
     * @name ShippingGroupRelationship#asMap
     * @return {Object} The map representaion of this instance.
     */
    ShippingGroupRelationship.prototype.asMap = function (emailAddress) {
      var shippingGroupMap = {};
      var shippingGroupKey = this.generateKey();
      var shippingGroupItemsMap = {};
      if (this.commerceItemId) {
        var shippingGroupItemKey = this.catRefId + "_" + this.commerceItemId;
      } else {
        var shippingGroupItemKey = this.catRefId;
      }

      var shippingAddress;
      // Checking if toJSON() is available in this.shippingAddress() before calling it, to map the address object
      // else use the old way of mapping.
      if(this.shippingAddress()) {
        if (this.shippingAddress().hasOwnProperty('toJSON')) {
          shippingAddress = this.shippingAddress().toJSON();
        } else {
          var mapping = {'ignore':['invalidTracker']};
          shippingAddress = ko.mapping.toJS(this.shippingAddress(), mapping);
        }
      }

      if(emailAddress &amp;&amp; shippingAddress &amp;&amp; ((!shippingAddress.email) || (shippingAddress.email != emailAddress))){
    	shippingAddress.email = emailAddress;
      }

      var shippingMethod;
      if (this.shippingMethod() &amp;&amp; this.shippingMethod().repositoryId) {
        shippingMethod = {value : this.shippingMethod().repositoryId};
      } else if (this.shippingMethod() &amp;&amp; this.shippingMethod().value) {
        shippingMethod = {value : this.shippingMethod().value};
      }
      var locationId = this.selectedStore() ? this.selectedStore().locationId : null;

      // Build shipping group items map.
      if (this.commerceItemId) {
        shippingGroupItemsMap[shippingGroupItemKey] = {
          productId: this.productId,
          catRefId: this.catRefId,
          quantity: parseFloat(this.quantity(), 10),
          // Currently childItems are not being supported in Shipping Group > items.
          // Changes to support passing the childItems in the Shipping Group
          childItems: this.childItems,
          commerceItemId: this.commerceItemId
        };
      } else {
        shippingGroupItemsMap[shippingGroupItemKey] = {
          productId: this.productId,
          catRefId: this.catRefId,
          childItems: this.childItems,
          quantity: parseFloat(this.quantity(), 10)
        };
      }

      // Build shipping group map.
      if (this.isPickupInStore()) {
        shippingGroupItemsMap[shippingGroupItemKey].availablePickupDate = this.availablePickupDate();
        shippingGroupItemsMap[shippingGroupItemKey].preferredPickupDate = this.preferredPickupDate();
        var firstName = this.firstName();
        var lastName = this.lastName();
        var phoneNumber = this.phoneNumber();
        shippingGroupMap[shippingGroupKey] = {
          items: shippingGroupItemsMap,
          type: ccConstants.INSTORE_PICKUP,
          locationId: locationId,
          firstName: firstName,
          lastName: lastName,
          phoneNumber: phoneNumber
        };
      } else {
        shippingGroupMap[shippingGroupKey] = {
          items: shippingGroupItemsMap,
          type: ccConstants.HARDGOOD_SHIPPING_GROUP_TYPE,
          shippingAddress: shippingAddress,
          shippingMethod: shippingMethod
        };
      }

      return shippingGroupMap;
    };

    /**
     * &lt;p>
     *   Add a specified number to the existing quantity. There is no removeQuantity method as passing negative numbers 
     *   gives the same result.
     * &lt;/p>
     *
     * @private
     * @function
     * @name ShippingGroupRelationship#addQuantity
     * @param {Number} adjustmentAmount - The amount to be added to the quantity (can be negative).
     */
    ShippingGroupRelationship.prototype.addQuantity = function (adjustmentAmount) {
      this.quantity(parseFloat(this.quantity()) + parseFloat(adjustmentAmount));
      this.updatableQuantity(this.quantity());
    };

    return ShippingGroupRelationship;
  });</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-ccKoErrorWrapper.html">ccKoErrorWrapper</a></li><li><a href="module-ccKoExtensions.html">ccKoExtensions</a></li></ul><h3>Classes</h3><ul><li><a href="Address.html">Address</a></li><li><a href="CartViewModel.html">CartViewModel</a></li><li><a href="CCStoreConfiguration.html">CCStoreConfiguration</a></li><li><a href="CheckoutScheduledOrder.html">CheckoutScheduledOrder</a></li><li><a href="delegatedAdminContacts.html">delegatedAdminContacts</a></li><li><a href="DynamicProperty.html">DynamicProperty</a></li><li><a href="DynamicPropertyMetaContainer.html">DynamicPropertyMetaContainer</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="GiftCardViewModel.html">GiftCardViewModel</a></li><li><a href="GiftProductListingViewModel.html">GiftProductListingViewModel</a></li><li><a href="global.html#InfinityViewModel">InfinityViewModel</a></li><li><a href="IntegrationViewModel.html">IntegrationViewModel</a></li><li><a href="ko.bindingHandlers.background.html">background</a></li><li><a href="ko.bindingHandlers.carouselSwipe.html">carouselSwipe</a></li><li><a href="ko.bindingHandlers.ccDateTime.html">ccDateTime</a></li><li><a href="ko.bindingHandlers.ccForm.html">ccForm</a></li><li><a href="ko.bindingHandlers.ccLink.html">ccLink</a></li><li><a href="ko.bindingHandlers.ccValidation.html">ccValidation</a></li><li><a href="ko.bindingHandlers.checkbox.html">checkbox</a></li><li><a href="ko.bindingHandlers.chosen.html">chosen</a></li><li><a href="ko.bindingHandlers.contextResourcesNamespace.html">contextResourcesNamespace</a></li><li><a href="ko.bindingHandlers.currency.html">currency</a></li><li><a href="ko.bindingHandlers.datepicker.html">datepicker</a></li><li><a href="ko.bindingHandlers.datepopover.html">datepopover</a></li><li><a href="ko.bindingHandlers.draggable.html">draggable</a></li><li><a href="ko.bindingHandlers.droppable.html">droppable</a></li><li><a href="ko.bindingHandlers.fade.html">fade</a></li><li><a href="ko.bindingHandlers.hover.html">hover</a></li><li><a href="ko.bindingHandlers.image.html">image</a></li><li><a href="ko.bindingHandlers.imageSource.html">imageSource</a></li><li><a href="ko.bindingHandlers.imageZoom.html">imageZoom</a></li><li><a href="ko.bindingHandlers.localeText.html">localeText</a></li><li><a href="ko.bindingHandlers.makeAccess.html">makeAccess</a></li><li><a href="ko.bindingHandlers.modal.html">modal</a></li><li><a href="ko.bindingHandlers.modalTabbingContraint.html">modalTabbingContraint</a></li><li><a href="ko.bindingHandlers.onRender.html">onRender</a></li><li><a href="ko.bindingHandlers.popeditor.html">popeditor</a></li><li><a href="ko.bindingHandlers.popover.html">popover</a></li><li><a href="ko.bindingHandlers.productImageSource.html">productImageSource</a></li><li><a href="ko.bindingHandlers.productVariantImageSource.html">productVariantImageSource</a></li><li><a href="ko.bindingHandlers.propertyEditor.html">propertyEditor</a></li><li><a href="ko.bindingHandlers.radio.html">radio</a></li><li><a href="ko.bindingHandlers.richTextEditor.html">richTextEditor</a></li><li><a href="ko.bindingHandlers.scrollAffix.html">scrollAffix</a></li><li><a href="ko.bindingHandlers.select2.html">select2</a></li><li><a href="ko.bindingHandlers.select2Tags.html">select2Tags</a></li><li><a href="ko.bindingHandlers.selectable.html">selectable</a></li><li><a href="ko.bindingHandlers.slide.html">slide</a></li><li><a href="ko.bindingHandlers.slider.html">slider</a></li><li><a href="ko.bindingHandlers.spectrum.html">spectrum</a></li><li><a href="ko.bindingHandlers.textCheck.html">textCheck</a></li><li><a href="ko.bindingHandlers.timepicker.html">timepicker</a></li><li><a href="ko.bindingHandlers.triggerMessage.html">triggerMessage</a></li><li><a href="ko.bindingHandlers.validatableTarget.html">validatableTarget</a></li><li><a href="ko.bindingHandlers.validatableValue.html">validatableValue</a></li><li><a href="ko.bindingHandlers.widgetLocaleText.html">widgetLocaleText</a></li><li><a href="koValidation.alphaNumeric.html">alphaNumeric</a></li><li><a href="koValidation.alphaNumericNoSpaces.html">alphaNumericNoSpaces</a></li><li><a href="koValidation.alphaNumericNoSpacesNoDashesWithSeperators.html">alphaNumericNoSpacesNoDashesWithSeperators</a></li><li><a href="koValidation.alphaNumericNoSpacesWithSeperators.html">alphaNumericNoSpacesWithSeperators</a></li><li><a href="koValidation.alphaNumericWithSeperators.html">alphaNumericWithSeperators</a></li><li><a href="koValidation.bool.html">bool</a></li><li><a href="koValidation.creditcard.html">creditcard</a></li><li><a href="koValidation.cvv.html">cvv</a></li><li><a href="koValidation.endmonth.html">endmonth</a></li><li><a href="koValidation.endyear.html">endyear</a></li><li><a href="koValidation.importFileName.html">importFileName</a></li><li><a href="koValidation.laterDate.html">laterDate</a></li><li><a href="koValidation.match.html">match</a></li><li><a href="koValidation.mediaZipFileName.html">mediaZipFileName</a></li><li><a href="koValidation.number.html">number</a></li><li><a href="koValidation.observablePattern.html">observablePattern</a></li><li><a href="koValidation.password.html">password</a></li><li><a href="koValidation.price.html">price</a></li><li><a href="koValidation.propertyIdAlreadyInUse.html">propertyIdAlreadyInUse</a></li><li><a href="koValidation.propertyNameAlreadyInUse.html">propertyNameAlreadyInUse</a></li><li><a href="koValidation.restrictSlashCharacters.html">restrictSlashCharacters</a></li><li><a href="koValidation.startmonth.html">startmonth</a></li><li><a href="koValidation.startyear.html">startyear</a></li><li><a href="koValidation.uniqueTrimmed.html">uniqueTrimmed</a></li><li><a href="koValidation.uniqueTrimmedCaseInsensitive.html">uniqueTrimmedCaseInsensitive</a></li><li><a href="koValidation.url.html">url</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.addTemplate.html">addTemplate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.agentBar.html">agentBar</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccDate.html">ccDate</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccNumber.html">ccNumber</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.ccResizeImage.html">ccResizeImage</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.disabled.html">disabled</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.element.html">element</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.embeddedAssistance.html">embeddedAssistance</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.fireChange.html">fireChange</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.inTabFlow.html">inTabFlow</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.noIndexMeta.html">noIndexMeta</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.previewBar.html">previewBar</a></li><li><a href="module-ccKoExtensions-ko.bindingHandlers.setContextVariable.html">setContextVariable</a></li><li><a href="multiCartViewModel.html">multiCartViewModel</a></li><li><a href="NavStateViewModel.html">NavStateViewModel</a></li><li><a href="OrderDetailsViewModel.html">OrderDetailsViewModel</a></li><li><a href="OrderHistoryViewModel.html">OrderHistoryViewModel</a></li><li><a href="OrdersPendingApprovalViewModel.html">OrdersPendingApprovalViewModel</a></li><li><a href="OrderViewModel.html">OrderViewModel</a></li><li><a href="Organization.html">Organization</a></li><li><a href="ParentOrganisation.html">ParentOrganisation</a></li><li><a href="ProductListingSearchViewModel.html">ProductListingSearchViewModel</a></li><li><a href="ProductListingViewModel.html">ProductListingViewModel</a></li><li><a href="ProductTypes.html">ProductTypes</a></li><li><a href="ProductViewModel.html">ProductViewModel</a></li><li><a href="PromotionUpsellContainer.html">PromotionUpsellContainer</a></li><li><a href="PubSub.topicNames.html">topicNames</a></li><li><a href="PurchaseListListingViewModel.html">PurchaseListListingViewModel</a></li><li><a href="PurchaseListViewModel.html">PurchaseListViewModel</a></li><li><a href="RegistrationRequestSearchViewModel.html">RegistrationRequestSearchViewModel</a></li><li><a href="resetCVV.html">resetCVV</a></li><li><a href="resetGiftCardPin.html">resetGiftCardPin</a></li><li><a href="resetPaymentDetails.html">resetPaymentDetails</a></li><li><a href="ReturnItem.html">ReturnItem</a></li><li><a href="ReturnViewModel.html">ReturnViewModel</a></li><li><a href="scheduledOrderList.html">scheduledOrderList</a></li><li><a href="SearchRestClient.html">SearchRestClient</a></li><li><a href="ServerData.html">ServerData</a></li><li><a href="UserViewModel.html">UserViewModel</a></li><li><a href="WidgetViewModel.html">WidgetViewModel</a></li><li><a href="WishlistContentViewModel.html">WishlistContentViewModel</a></li></ul><h3>Namespaces</h3><ul><li><a href="ko.bindingHandlers.html">bindingHandlers</a></li><li><a href="ko.extenders.html">extenders</a></li><li><a href="koValidation.html">koValidation</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addItemToPurchaseList">addItemToPurchaseList</a></li><li><a href="global.html#callWidgetMethodIfApplicable">callWidgetMethodIfApplicable</a></li><li><a href="global.html#CartViewModel#deleteParticularIncompleteOrdersDeletesanincompleteorderbyorderId">CartViewModel#deleteParticularIncompleteOrdersDeletes an incomplete order by orderId</a></li><li><a href="global.html#CCEETagProcessor">CCEETagProcessor</a></li><li><a href="global.html#doesSiteExist">doesSiteExist</a></li><li><a href="global.html#fetchSkuDetailsListError">fetchSkuDetailsListError</a></li><li><a href="global.html#fetchSkuDetailsListSuccess">fetchSkuDetailsListSuccess</a></li><li><a href="global.html#formatSiteText">formatSiteText</a></li><li><a href="global.html#handleInitiateEditSuccess">handleInitiateEditSuccess</a></li><li><a href="global.html#isModified">isModified</a></li><li><a href="global.html#isValidDeterminewhetherornotthepaymentdetailsobjectisvalidbasedonthevalidityofitscomponentparts.Thiswillnotcauseerrormessagestobedisplayedforanyobservablevaluesthatareunchangedandhaveneverreceivedfocusontherelatedformfield(s).">isValidDetermine whether or not the payment details object is validbased on the validity of its component parts. This will notcause error messages to be displayed for any observable valuesthat are unchanged and have never received focus on the related form field(s).</a></li><li><a href="global.html#justFocused">justFocused</a></li><li><a href="global.html#mapProperties">mapProperties</a></li><li><a href="global.html#MENU_CLOSE_TIMEOUT">MENU_CLOSE_TIMEOUT</a></li><li><a href="global.html#populateData">populateData</a></li><li><a href="global.html#populateProductData">populateProductData</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetModified">resetModified</a></li><li><a href="global.html#Resetsstylingforthelazilyloadedimage">Resets styling for the lazily loaded image</a></li><li><a href="global.html#Setsupstylingfortheimagetobelazilyloaded">Sets up styling for the image to be lazily loaded</a></li><li><a href="global.html#ShopperContextViewModel">ShopperContextViewModel</a></li><li><a href="global.html#thelistofpropertiestoignorewhilecopyingdynamicpropertiestoaddressobject">the list of properties to ignore while copying dynamic properties to address object</a></li><li><a href="global.html#validatePaymentDetailsForceallrelevantmemberobservablestoperformtheirvalidationnow&displaytheerrors(ifany)">validatePaymentDetailsForce all relevant member observables to perform theirvalidation now & display the errors (if any)</a></li><li><a href="global.html#WidgetQueue">WidgetQueue</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0</a> on Wed Feb 26 2020 18:22:23 GMT+0530 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
